# UT03. Bloque 4. Ejercicios de Programaci√≥n modular

Para la realizaci√≥n de estos ejercicios, debes crear un nuevo proyecto en VSCode, con el nombre `B03.4-prog.modular`.<br>
Para cada secci√≥n crea un fichero `SeccionXX.java`, donde XX corresponda a 01,02,03,...

Desde el main, crea un men√∫ para que se llamen para uno de los m√©todos de los ejercicios.

Ejemplo:

```java
public static void main(String[] args) {

    Scanner teclado = new Scanner(System.in);
    int opcion;
    
    do {
      //-- mostrar menu --

      switch (opcion) {
        case 1:
            //--llamar a m√©todo Ejercicio1
            break;
        case 2:
            //--llamar a m√©todo Ejercicio2
            break;
      }

    } while (opcion != 0) 
}

public static void Ej01() {
  //codigo del ejercicio  
}

public static void Ej02() {
  //codigo del ejercicio  
}

```

### üìö Secci√≥n 1: Sobrecarga de M√©todos

La sobrecarga nos permite tener m√∫ltiples m√©todos con el **mismo nombre**, siempre que sus **par√°metros sean diferentes** (ya sea en n√∫mero o en tipo). ¬°Es como tener una herramienta que funciona de distintas formas seg√∫n c√≥mo la uses!

**Ejercicio 1: Saludos Variados üëã**

Crea un procedimiento `saludar`.
- Una versi√≥n no debe recibir par√°metros y simplemente imprimir√° "¬°Hola, mundo!".
- Otra versi√≥n recibir√° un `String` con un nombre e imprimir√° "Hola, [nombre]".
- Llama a ambas versiones desde `main`.

**Ejercicio 2: Calculando √Åreas üìê**

Crea una funci√≥n `calcularArea` que devuelva un `double`.
- Una versi√≥n recibir√° un `double` (el lado de un cuadrado) y devolver√° el √°rea.
- Otra versi√≥n recibir√° dos `double` (base y altura de un rect√°ngulo) y devolver√° el √°rea.
- Prueba ambas desde `main` y muestra los resultados.

**Ejercicio 3: Describiendo Personas y Mascotas üßë‚Äçü§ù‚Äçüêà**

Crea un procedimiento `describir`.
- Una versi√≥n recibir√° un `String` (nombre) y un `int` (edad) para describir una persona. Ej: "Ana tiene 30 a√±os".
- Otra versi√≥n recibir√° un `String` (nombre) y otro `String` (especie) para describir una mascota. Ej: "Fido es un perro".

**Ejercicio 4: Encontrando el M√°ximo üèÜ**

Crea una funci√≥n `encontrarMaximo`.
- Una versi√≥n que reciba dos `int` y devuelva el mayor.
- Una versi√≥n que reciba tres `int` y devuelva el mayor.
- Una versi√≥n que reciba dos `double` y devuelva el mayor.

---

### üßµ Secci√≥n 2: Trabajo con Strings y Posiciones

Los `String` no son solo para guardar texto, ¬°podemos inspeccionarlos letra por letra!

**Ejercicio 5: La Primera Letra üÖ∞Ô∏è**

Crea una funci√≥n `obtenerPrimeraLetra` que reciba un `String` y devuelva su primer car√°cter (`char`). Desde `main`, pide una palabra al usuario y muestra su primera letra.

> **Pista:** La funci√≥n que necesitas es `palabra.charAt(0)`.

**Ejercicio 6: La √öltima Letra Omega**

Crea una funci√≥n `obtenerUltimaLetra` que reciba un `String` y devuelva su √∫ltimo car√°cter (`char`).
> **Pista:** Para obtener la √∫ltima posici√≥n, necesitar√°s la longitud del String con `palabra.length()`. Recuerda que las posiciones empiezan en 0.

**Ejercicio 7: Contador de Caracteres Espec√≠ficos üîç**

Crea una funci√≥n `contarCaracter` que reciba un `String` (el texto) y un `char` (el car√°cter a buscar). La funci√≥n debe devolver cu√°ntas veces aparece ese car√°cter en el texto.
Ej: `contarCaracter("banana", 'a')` deber√≠a devolver 3.

**Ejercicio 8: ¬øEs un Pal√≠ndromo? üîÑ**

Un pal√≠ndromo es una palabra que se lee igual de izquierda a derecha que de derecha a izquierda (ej: "oso", "reconocer"). Crea una funci√≥n `esPalindromo` que reciba un `String` y devuelva `true` si es un pal√≠ndromo y `false` si no lo es.

> **üí° Pista Dif√≠cil:** Puedes usar un bucle `for` que compare el car√°cter en la posici√≥n `i` con el car√°cter en la posici√≥n `longitud - 1 - i`. Si en alg√∫n momento no coinciden, ya sabes que no es un pal√≠ndromo y puedes hacer un `return false;`.

---

### üåê Secci√≥n 3: √Åmbito de las Variables (Scope)

¬øD√≥nde "vive" una variable? No todas las variables son accesibles desde todas partes. ¬°Vamos a investigarlo!

**Ejercicio 9: El Esp√≠a Oculto (Shadowing)üïµÔ∏è**

1.  Declara una variable `static int miVariableGlobal = 10;` al nivel de la clase (fuera de cualquier m√©todo).
2.  En `main`, imprime el valor de `miVariableGlobal`.
3.  Crea un procedimiento `probarVariableLocal` donde declares *otra* variable con el mismo nombre: `int miVariableGlobal = 25;`. Imprime su valor dentro de este m√©todo.
4.  Llama a `probarVariableLocal` desde `main`.
5.  Despu√©s de la llamada, vuelve a imprimir el valor de la variable global en `main`. ¬øQu√© observas? ¬øPor qu√© la variable global no cambi√≥?

**Ejercicio 10: Contador de Puntuaci√≥n Global üéÆ**

1.  Declara una variable global `static int puntuacion = 0;`.
2.  Crea un procedimiento `incrementarPuntuacion(int puntos)` que sume los puntos a la variable `puntuacion`.
3.  Crea un procedimiento `mostrarPuntuacion()` que imprima el valor actual de `puntuacion`.
4.  Desde `main`, llama a `incrementarPuntuacion` varias veces con distintos valores y llama a `mostrarPuntuacion` entre medias para ver c√≥mo cambia.

**Ejercicio 11: La Variable Fantasma üëª**

Copia el siguiente c√≥digo e intenta compilarlo. ¬øPor qu√© da un error? Expl√≠calo con tus palabras.

```java
public static void metodoA() {
    int variableFantasma = 100;
    System.out.println("Dentro del m√©todo A, el valor es: " + variableFantasma);
}

public static void main(String[] args) {
    metodoA();
    // Esta l√≠nea dar√° error. ¬øPor qu√©?
    System.out.println("En main, el valor es: " + variableFantasma);
}
```
---

### üéØ Secci√≥n 4: Reglas de Exactitud de Tipos (Casting)

Java es muy estricto con los tipos. A veces, necesitamos decirle expl√≠citamente: "¬°Conf√≠a en m√≠, s√© que este `int` puede tratarse como un `byte`!". A eso se le llama **castear**.

**Ejercicio 12: El Casting Forzado Ïñµ**

1.  Crea un procedimiento `procesarDatoPeque√±o` que reciba como par√°metro un `byte`.
2.  En `main`, declara una variable `int numero = 50;`.
3.  Intenta llamar a `procesarDatoPeque√±o(numero)`. Ver√°s que Java da un error.
4.  Corrige el error haciendo un casting expl√≠cito: `procesarDatoPeque√±o((byte)numero);`.

**Ejercicio 13: La Media con Decimales ‚ûó**

1.  Crea una funci√≥n `calcularMedia` que reciba dos `int` y devuelva un `double` con su media.
2.  En `main`, llama a la funci√≥n con los n√∫meros 5 y 2. `calcularMedia(5, 2)`.
3.  Si simplemente haces `return (a + b) / 2;` ver√°s que el resultado es 3.0, ¬°lo cual es incorrecto! La divisi√≥n de enteros trunca los decimales.
4.  Soluci√≥nalo haciendo un casting de al menos uno de los n√∫meros a `double` *antes* de la operaci√≥n: `return (double)(a + b) / 2;`.

**Ejercicio 14: De N√∫mero a Car√°cter üî¢‚Üíüî°**

El c√≥digo ASCII asocia n√∫meros a caracteres (ej: el 65 es la 'A').
1.  Crea un procedimiento `imprimirCaracter` que reciba un `char`.
2.  En `main`, declara un `int codigo = 65;`.
3.  Llama a `imprimirCaracter` pas√°ndole la variable `codigo` casteada a `char`. Prueba con otros n√∫meros como 97 o 48.

---

### üîÑ Secci√≥n 5: Recursividad

La recursividad es una t√©cnica en la que una funci√≥n se llama a s√≠ misma para resolver un problema. ¬°Es poderosa, pero hay que tener cuidado de no crear un bucle infinito! Toda funci√≥n recursiva necesita un **caso base** para detenerse.

**Ejercicio 15: Factorial Recursivo (!)**

El factorial de un n√∫mero `n` (escrito `n!`) es `n * (n-1) * (n-2) * ... * 1`.
Crea una funci√≥n `factorial(int n)` que lo calcule de forma recursiva.
> **üí° Pista:** La definici√≥n recursiva es `factorial(n) = n * factorial(n - 1)`. El **caso base** es cuando `n` es 0 o 1, en cuyo caso el factorial es 1.

**Ejercicio 16: Suma hasta N ‚ûï**

Crea una funci√≥n `sumarHasta(int n)` que sume todos los n√∫meros desde 1 hasta `n` de forma recursiva. Ej: `sumarHasta(5)` es `5 + 4 + 3 + 2 + 1 = 15`.
> **üí° Pista:** La l√≥gica es `sumarHasta(n) = n + sumarHasta(n - 1)`. El **caso base** es cuando `n` es 1.

**Ejercicio 17: Cuenta Atr√°s para el Despegue üöÄ**

Crea un procedimiento recursivo `cuentaAtras(int n)` que imprima los n√∫meros desde `n` hasta 1, y al final "¬°Despegue!".
Ej: `cuentaAtras(5)` imprimir√° 5, 4, 3, 2, 1, ¬°Despegue!.

> **üí° Pista:** El **caso base** es cuando `n` es 0, momento en el que imprimes "¬°Despegue!". Si no, imprimes `n` y luego llamas a `cuentaAtras(n - 1)`.

**Ejercicio 18: Potencia Recursiva üîã**

Crea una funci√≥n `potencia(int base, int exponente)` que calcule `base` elevado a `exponente` de forma recursiva.

> **üí° Pista:** La definici√≥n es `potencia(b, e) = b * potencia(b, e - 1)`. El **caso base** es cuando el exponente es 0, en cuyo caso el resultado es 1.

---

### üõ°Ô∏è Secci√≥n 6: Control de Errores (Excepciones)

Los programas pueden fallar por razones inesperadas (el usuario introduce texto en lugar de un n√∫mero, se intenta dividir por cero...). ¬°Vamos a aprender a "atrapar" esos errores para que nuestro programa no se cierre!

**Ejercicio 19: Divisi√≥n Segura ü¶∫**

Pide al usuario dos n√∫meros enteros. Intenta dividirlos e imprimir el resultado. Usa un bloque `try-catch` para capturar la posible `ArithmeticException` si el usuario introduce un 0 como segundo n√∫mero. En el `catch`, muestra un mensaje amigable como "Error: No se puede dividir por cero."

**Ejercicio 20: Lector de N√∫meros a Prueba de Tontos  foolproof**

Pide al usuario que introduzca su edad usando un `Scanner`. Usa un bloque `try-catch` para capturar la `InputMismatchException` que ocurre si el usuario escribe "veinte" en lugar de "20". En el `catch`, informa al usuario del error.

**Ejercicio 21: El Bloque `finally` Siempre Gana üèÖ**

Simula la conexi√≥n a una base de datos.
1.  En el bloque `try`, imprime "Abriendo conexi√≥n..." y luego provoca un error de divisi√≥n por cero.
2.  En el bloque `catch`, imprime "¬°Error encontrado!".
3.  En el bloque `finally`, imprime "Cerrando conexi√≥n...".
Observa que el bloque `finally` se ejecuta siempre, haya error o no.

---

### üì¶ Secci√≥n 7: ¬°A Organizarse con Paquetes!

A medida que los programas crecen, guardamos las clases en carpetas llamadas **paquetes** para tener todo ordenado.

**Ejercicio 22: Creando Nuestra Librer√≠a - Estructura üèóÔ∏è**

1.  Dentro de tu carpeta `src`, crea una estructura de carpetas: `com/miempresa/utilidades`.
2.  En la misma `src`, crea otra: `com/miempresa/principal`.

**Ejercicio 23: Utilidades Matem√°ticas üî¢**

1.  Dentro de la carpeta `utilidades`, crea un fichero `Mates.java`.
2.  Aseg√∫rate de que la primera l√≠nea del fichero sea `package com.miempresa.utilidades;`.
3.  Dentro, crea una clase `Mates` con funciones `public static` como `sumar(int a, int b)`, `restar(int a, int b)` y la funci√≥n `esPrimo(int n)` que ya creaste.

**Ejercicio 24: Utilidades de Texto ‚úçÔ∏è**

1.  En la misma carpeta `utilidades`, crea un fichero `Cadenas.java` (con su `package` correspondiente).
2.  Dentro, crea una clase `Cadenas` con funciones `public static` como `esPalindromo(String s)` y `contarVocales(String s)`.

**Ejercicio 25: Usando Nuestra Librer√≠a ‚öôÔ∏è**

1.  Ahora, ve a la carpeta `principal` y crea un fichero `Main.java` (con su `package` correspondiente).
2.  Para poder usar las funciones que creaste, tienes que **importarlas**. Al principio del fichero, escribe:
    ```java
    import com.miempresa.utilidades.Mates;
    import com.miempresa.utilidades.Cadenas;
    ```
3.  Ahora, desde el m√©todo `main` de la clase `Main`, puedes llamar a tus funciones as√≠:
    ```java
    int suma = Mates.sumar(10, 5);
    boolean palindromo = Cadenas.esPalindromo("oso");
    System.out.println("La suma es: " + suma);
    ```


