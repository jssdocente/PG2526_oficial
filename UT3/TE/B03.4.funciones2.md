# UT03. Bloque 4. Ejercicios de ProgramaciÃ³n modular

| Resultados Aprendizaje | CE |
| ----------------------------------- | ----------- |
| RA3             | CE3a, CE3b, CE3c, CE3d, CE3e, CE3f, CE3g, CE3h, CE3i |

Para la realizaciÃ³n de estos ejercicios, debes crear un nuevo proyecto en VSCode, con el nombre `B03.4-prog.modular`.<br>
Para cada secciÃ³n crea un fichero `SeccionXX.java`, donde XX corresponda a 01,02,03,...

Desde el main, crea un menÃº para que se llamen para uno de los mÃ©todos de los ejercicios.

Ejemplo:

```java
public static void main(String[] args) {

    Scanner teclado = new Scanner(System.in);
    int opcion;
    
    do {
      //-- mostrar menu --

      switch (opcion) {
        case 1:
            //--llamar a mÃ©todo Ejercicio1
            break;
        case 2:
            //--llamar a mÃ©todo Ejercicio2
            break;
      }

    } while (opcion != 0) 
}

public static void Ej01() {
  //codigo del ejercicio  
}

public static void Ej02() {
  //codigo del ejercicio  
}

```

### ğŸ“š SecciÃ³n 1: Sobrecarga de MÃ©todos

La sobrecarga nos permite tener mÃºltiples mÃ©todos con el **mismo nombre**, siempre que sus **parÃ¡metros sean diferentes** (ya sea en nÃºmero o en tipo). Â¡Es como tener una herramienta que funciona de distintas formas segÃºn cÃ³mo la uses!

**Ejercicio 1: Saludos Variados ğŸ‘‹**

Crea un procedimiento `saludar`.
- Una versiÃ³n no debe recibir parÃ¡metros y simplemente imprimirÃ¡ "Â¡Hola, mundo!".
- Otra versiÃ³n recibirÃ¡ un `String` con un nombre e imprimirÃ¡ "Hola, [nombre]".
- Llama a ambas versiones desde `main`.

**Ejercicio 2: Calculando Ãreas ğŸ“**

Crea una funciÃ³n `calcularArea` que devuelva un `double`.
- Una versiÃ³n recibirÃ¡ un `double` (el lado de un cuadrado) y devolverÃ¡ el Ã¡rea.
- Otra versiÃ³n recibirÃ¡ dos `double` (base y altura de un rectÃ¡ngulo) y devolverÃ¡ el Ã¡rea.
- Prueba ambas desde `main` y muestra los resultados.

**Ejercicio 3: Describiendo Personas y Mascotas ğŸ§‘â€ğŸ¤â€ğŸˆ**

Crea un procedimiento `describir`.
- Una versiÃ³n recibirÃ¡ un `String` (nombre) y un `int` (edad) para describir una persona. Ej: "Ana tiene 30 aÃ±os".
- Otra versiÃ³n recibirÃ¡ un `String` (nombre) y otro `String` (especie) para describir una mascota. Ej: "Fido es un perro".

**Ejercicio 4: Encontrando el MÃ¡ximo ğŸ†**

Crea una funciÃ³n `encontrarMaximo`.
- Una versiÃ³n que reciba dos `int` y devuelva el mayor.
- Una versiÃ³n que reciba tres `int` y devuelva el mayor.
- Una versiÃ³n que reciba dos `double` y devuelva el mayor.

---

### ğŸ§µ SecciÃ³n 2: Trabajo con Strings y Posiciones

Los `String` no son solo para guardar texto, Â¡podemos inspeccionarlos letra por letra!

**Ejercicio 5: La Primera Letra ğŸ…°ï¸**

Crea una funciÃ³n `obtenerPrimeraLetra` que reciba un `String` y devuelva su primer carÃ¡cter (`char`). Desde `main`, pide una palabra al usuario y muestra su primera letra.

> **Pista:** La funciÃ³n que necesitas es `palabra.charAt(0)`.

**Ejercicio 6: La Ãšltima Letra Omega**

Crea una funciÃ³n `obtenerUltimaLetra` que reciba un `String` y devuelva su Ãºltimo carÃ¡cter (`char`).
> **Pista:** Para obtener la Ãºltima posiciÃ³n, necesitarÃ¡s la longitud del String con `palabra.length()`. Recuerda que las posiciones empiezan en 0.

**Ejercicio 7: Contador de Caracteres EspecÃ­ficos ğŸ”**

Crea una funciÃ³n `contarCaracter` que reciba un `String` (el texto) y un `char` (el carÃ¡cter a buscar). La funciÃ³n debe devolver cuÃ¡ntas veces aparece ese carÃ¡cter en el texto.
Ej: `contarCaracter("banana", 'a')` deberÃ­a devolver 3.

**Ejercicio 8: Â¿Es un PalÃ­ndromo? ğŸ”„**

Un palÃ­ndromo es una palabra que se lee igual de izquierda a derecha que de derecha a izquierda (ej: "oso", "reconocer"). Crea una funciÃ³n `esPalindromo` que reciba un `String` y devuelva `true` si es un palÃ­ndromo y `false` si no lo es.

> **ğŸ’¡ Pista DifÃ­cil:** Puedes usar un bucle `for` que compare el carÃ¡cter en la posiciÃ³n `i` con el carÃ¡cter en la posiciÃ³n `longitud - 1 - i`. Si en algÃºn momento no coinciden, ya sabes que no es un palÃ­ndromo y puedes hacer un `return false;`.

---

### ğŸŒ SecciÃ³n 3: Ãmbito de las Variables (Scope)

Â¿DÃ³nde "vive" una variable? No todas las variables son accesibles desde todas partes. Â¡Vamos a investigarlo!

**Ejercicio 9: El EspÃ­a Oculto (Shadowing)ğŸ•µï¸**

1.  Declara una variable `static int miVariableGlobal = 10;` al nivel de la clase (fuera de cualquier mÃ©todo).
2.  En `main`, imprime el valor de `miVariableGlobal`.
3.  Crea un procedimiento `probarVariableLocal` donde declares *otra* variable con el mismo nombre: `int miVariableGlobal = 25;`. Imprime su valor dentro de este mÃ©todo.
4.  Llama a `probarVariableLocal` desde `main`.
5.  DespuÃ©s de la llamada, vuelve a imprimir el valor de la variable global en `main`. Â¿QuÃ© observas? Â¿Por quÃ© la variable global no cambiÃ³?

**Ejercicio 10: Contador de PuntuaciÃ³n Global ğŸ®**

1.  Declara una variable global `static int puntuacion = 0;`.
2.  Crea un procedimiento `incrementarPuntuacion(int puntos)` que sume los puntos a la variable `puntuacion`.
3.  Crea un procedimiento `mostrarPuntuacion()` que imprima el valor actual de `puntuacion`.
4.  Desde `main`, llama a `incrementarPuntuacion` varias veces con distintos valores y llama a `mostrarPuntuacion` entre medias para ver cÃ³mo cambia.

**Ejercicio 11: La Variable Fantasma ğŸ‘»**

Copia el siguiente cÃ³digo e intenta compilarlo. Â¿Por quÃ© da un error? ExplÃ­calo con tus palabras.

```java
public static void metodoA() {
    int variableFantasma = 100;
    System.out.println("Dentro del mÃ©todo A, el valor es: " + variableFantasma);
}

public static void main(String[] args) {
    metodoA();
    // Esta lÃ­nea darÃ¡ error. Â¿Por quÃ©?
    System.out.println("En main, el valor es: " + variableFantasma);
}
```
---

### ğŸ¯ SecciÃ³n 4: Reglas de Exactitud de Tipos (Casting)

Java es muy estricto con los tipos. A veces, necesitamos decirle explÃ­citamente: "Â¡ConfÃ­a en mÃ­, sÃ© que este `int` puede tratarse como un `byte`!". A eso se le llama **castear**.

**Ejercicio 12: El Casting Forzado ì–µ**

1.  Crea un procedimiento `procesarDatoPequeÃ±o` que reciba como parÃ¡metro un `byte`.
2.  En `main`, declara una variable `int numero = 50;`.
3.  Intenta llamar a `procesarDatoPequeÃ±o(numero)`. VerÃ¡s que Java da un error.
4.  Corrige el error haciendo un casting explÃ­cito: `procesarDatoPequeÃ±o((byte)numero);`.

**Ejercicio 13: La Media con Decimales â—**

1.  Crea una funciÃ³n `calcularMedia` que reciba dos `int` y devuelva un `double` con su media.
2.  En `main`, llama a la funciÃ³n con los nÃºmeros 5 y 2. `calcularMedia(5, 2)`.
3.  Si simplemente haces `return (a + b) / 2;` verÃ¡s que el resultado es 3.0, Â¡lo cual es incorrecto! La divisiÃ³n de enteros trunca los decimales.
4.  SoluciÃ³nalo haciendo un casting de al menos uno de los nÃºmeros a `double` *antes* de la operaciÃ³n: `return (double)(a + b) / 2;`.

**Ejercicio 14: De NÃºmero a CarÃ¡cter ğŸ”¢â†’ğŸ”¡**

El cÃ³digo ASCII asocia nÃºmeros a caracteres (ej: el 65 es la 'A').
1.  Crea un procedimiento `imprimirCaracter` que reciba un `char`.
2.  En `main`, declara un `int codigo = 65;`.
3.  Llama a `imprimirCaracter` pasÃ¡ndole la variable `codigo` casteada a `char`. Prueba con otros nÃºmeros como 97 o 48.

---

### ğŸ”„ SecciÃ³n 5: Recursividad

La recursividad es una tÃ©cnica en la que una funciÃ³n se llama a sÃ­ misma para resolver un problema. Â¡Es poderosa, pero hay que tener cuidado de no crear un bucle infinito! Toda funciÃ³n recursiva necesita un **caso base** para detenerse.

**Ejercicio 15: Factorial Recursivo (!)**

El factorial de un nÃºmero `n` (escrito `n!`) es `n * (n-1) * (n-2) * ... * 1`.
Crea una funciÃ³n `factorial(int n)` que lo calcule de forma recursiva.
> **ğŸ’¡ Pista:** La definiciÃ³n recursiva es `factorial(n) = n * factorial(n - 1)`. El **caso base** es cuando `n` es 0 o 1, en cuyo caso el factorial es 1.

**Ejercicio 16: Suma hasta N â•**

Crea una funciÃ³n `sumarHasta(int n)` que sume todos los nÃºmeros desde 1 hasta `n` de forma recursiva. Ej: `sumarHasta(5)` es `5 + 4 + 3 + 2 + 1 = 15`.
> **ğŸ’¡ Pista:** La lÃ³gica es `sumarHasta(n) = n + sumarHasta(n - 1)`. El **caso base** es cuando `n` es 1.

**Ejercicio 17: Cuenta AtrÃ¡s para el Despegue ğŸš€**

Crea un procedimiento recursivo `cuentaAtras(int n)` que imprima los nÃºmeros desde `n` hasta 1, y al final "Â¡Despegue!".
Ej: `cuentaAtras(5)` imprimirÃ¡ 5, 4, 3, 2, 1, Â¡Despegue!.

> **ğŸ’¡ Pista:** El **caso base** es cuando `n` es 0, momento en el que imprimes "Â¡Despegue!". Si no, imprimes `n` y luego llamas a `cuentaAtras(n - 1)`.

**Ejercicio 18: Potencia Recursiva ğŸ”‹**

Crea una funciÃ³n `potencia(int base, int exponente)` que calcule `base` elevado a `exponente` de forma recursiva.

> **ğŸ’¡ Pista:** La definiciÃ³n es `potencia(b, e) = b * potencia(b, e - 1)`. El **caso base** es cuando el exponente es 0, en cuyo caso el resultado es 1.

---

### ğŸ›¡ï¸ SecciÃ³n 6: Control de Errores (Excepciones)

Los programas pueden fallar por razones inesperadas (el usuario introduce texto en lugar de un nÃºmero, se intenta dividir por cero...). Â¡Vamos a aprender a "atrapar" esos errores para que nuestro programa no se cierre!

**Ejercicio 19: DivisiÃ³n Segura ğŸ¦º**

Pide al usuario dos nÃºmeros enteros. Intenta dividirlos e imprimir el resultado. Usa un bloque `try-catch` para capturar la posible `ArithmeticException` si el usuario introduce un 0 como segundo nÃºmero. En el `catch`, muestra un mensaje amigable como "Error: No se puede dividir por cero."

**Ejercicio 20: Lector de NÃºmeros a Prueba de Tontos  foolproof**

Pide al usuario que introduzca su edad usando un `Scanner`. Usa un bloque `try-catch` para capturar la `InputMismatchException` que ocurre si el usuario escribe "veinte" en lugar de "20". En el `catch`, informa al usuario del error.

**Ejercicio 21: El Bloque `finally` Siempre Gana ğŸ…**

Simula la conexiÃ³n a una base de datos.
1.  En el bloque `try`, imprime "Abriendo conexiÃ³n..." y luego provoca un error de divisiÃ³n por cero.
2.  En el bloque `catch`, imprime "Â¡Error encontrado!".
3.  En el bloque `finally`, imprime "Cerrando conexiÃ³n...".
Observa que el bloque `finally` se ejecuta siempre, haya error o no.

---

### ğŸ“¦ SecciÃ³n 7: Â¡A Organizarse con Paquetes!

A medida que los programas crecen, guardamos las clases en carpetas llamadas **paquetes** para tener todo ordenado.

**Ejercicio 22: Creando Nuestra LibrerÃ­a - Estructura ğŸ—ï¸**

1.  Dentro de tu carpeta `src`, crea una estructura de carpetas: `com/miempresa/utilidades`.
2.  En la misma `src`, crea otra: `com/miempresa/principal`.

**Ejercicio 23: Utilidades MatemÃ¡ticas ğŸ”¢**

1.  Dentro de la carpeta `utilidades`, crea un fichero `Mates.java`.
2.  AsegÃºrate de que la primera lÃ­nea del fichero sea `package com.miempresa.utilidades;`.
3.  Dentro, crea una clase `Mates` con funciones `public static` como `sumar(int a, int b)`, `restar(int a, int b)` y la funciÃ³n `esPrimo(int n)` que ya creaste.

**Ejercicio 24: Utilidades de Texto âœï¸**

1.  En la misma carpeta `utilidades`, crea un fichero `Cadenas.java` (con su `package` correspondiente).
2.  Dentro, crea una clase `Cadenas` con funciones `public static` como `esPalindromo(String s)` y `contarVocales(String s)`.

**Ejercicio 25: Usando Nuestra LibrerÃ­a âš™ï¸**

1.  Ahora, ve a la carpeta `principal` y crea un fichero `Main.java` (con su `package` correspondiente).
2.  Para poder usar las funciones que creaste, tienes que **importarlas**. Al principio del fichero, escribe:
    ```java
    import com.miempresa.utilidades.Mates;
    import com.miempresa.utilidades.Cadenas;
    ```
3.  Ahora, desde el mÃ©todo `main` de la clase `Main`, puedes llamar a tus funciones asÃ­:
    ```java
    int suma = Mates.sumar(10, 5);
    boolean palindromo = Cadenas.esPalindromo("oso");
    System.out.println("La suma es: " + suma);
    ```


