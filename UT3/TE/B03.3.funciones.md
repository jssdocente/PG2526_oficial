# UT03. Bloque 3. Ejercicios: Trabajo con funciones

| Resultados Aprendizaje | CE |
| ----------------------------------- | ----------- |
| RA3             | CE3a, CE3b, CE3c, CE3d, CE3e, CE3f, CE3g, CE3h, CE3i |

### Nivel 1: Los Fundamentos

En este nivel nos centraremos en la sintaxis básica y la diferencia entre un método que hace algo (procedimiento) y uno que calcula y devuelve un valor (función).

#### **Ejercicio 1: ¡Hola, Procedimiento!**

- **Concepto:** Procedimiento (un método `void`).
- **Objetivo:** Crear un método que realice una acción simple: imprimir un saludo personalizado.
- **Enunciado:**
  1.  Crea un método llamado `saludarUsuario` que reciba un parámetro de tipo `String` llamado `nombre`.
  2.  Dentro de este método, imprime por pantalla un saludo como "¡Hola, [nombre]! Bienvenido a Java.".
  3.  Desde el método `main`, llama a `saludarUsuario` dos veces con nombres diferentes (por ejemplo, "Ana" y "Carlos").

#### **Ejercicio 2: La Tabla de Multiplicar**

- **Concepto:** Procedimiento con lógica interna.
- **Objetivo:** Crear un método que encapsule la lógica de un bucle.
- **Enunciado:**
  1.  Crea un método `mostrarTablaDeMultiplicar` que reciba un parámetro de tipo `int` llamado `numero`.
  2.  El método debe imprimir la tabla de multiplicar de ese número, del 1 al 10. Por ejemplo, si recibe un 7, imprimirá "7 x 1 = 7", "7 x 2 = 14", etc.
  3.  Desde `main`, pide al usuario un número y luego llama a tu método para mostrar su tabla.

#### **Ejercicio 3: Mi Primera Función**

- **Concepto:** Función (un método que devuelve un valor con `return`).
- **Objetivo:** Crear un método que realice un cálculo y devuelva el resultado.
- **Enunciado:**
  1.  Crea un método llamado `sumar` que reciba dos parámetros `int` (`numeroA` y `numeroB`).
  2.  El método debe calcular la suma de ambos números y, usando la palabra `return`, devolver el resultado. El método debe ser de tipo `int`.
  3.  Desde `main`, llama al método `sumar` con dos números, guarda el resultado en una variable e imprímela.

#### **Ejercicio 4: ¿Es Par o Impar?**

- **Concepto:** Función que devuelve un `boolean`.
- **Objetivo:** Entender que las funciones pueden devolver cualquier tipo de dato primitivo.
- **Enunciado:**
  1.  Crea una función llamada `esPar` que reciba un `int` como parámetro.
  2.  La función debe devolver `true` si el número es par, y `false` si es impar.
  3.  **Pista:** El operador módulo (`%`) es tu mejor amigo aquí. `numero % 2` te dirá el resto de dividir `numero` entre 2.
  4.  Desde `main`, llama a esta función dentro de un `if` para imprimir un mensaje adecuado, como "El número 8 es par" o "El número 5 es impar".

#### **Ejercicio 5: El Misterio del Paso por Valor**

- **Concepto:** Demostración del paso por valor con tipos primitivos.
- **Objetivo:** Comprobar que Java no permite modificar los parámetros primitivos de forma externa (no existe el paso por referencia para primitivos).
- **Enunciado:**
  1.  En `main`, declara dos variables `int`, `a = 10` y `b = 20`.
  2.  Crea un procedimiento `void` llamado `intentarIntercambiar` que reciba dos parámetros `int`, `x` e `y`.
  3.  Dentro de `intentarIntercambiar`, escribe el código para intercambiar los valores de `x` e `y`. Puedes usar una variable temporal. Imprime los valores de `x` e `y` _dentro_ del método al final para ver que se han intercambiado.
  4.  En `main`, antes de llamar al método, imprime los valores de `a` y `b`. Luego llama a `intentarIntercambiar(a, b)`. Finalmente, después de la llamada, vuelve a imprimir los valores de `a` y `b`.
  5.  **Pregunta para reflexionar:** ¿Por qué los valores de `a` y `b` no cambiaron en `main`, aunque sí lo hicieron dentro del método? (La respuesta es el paso por valor: el método recibió solo "fotocopias" de los valores).

---

### Nivel 2: Aplicando "Divide y Vencerás"

Ahora que sabemos crear métodos, vamos a usarlos para resolver problemas más grandes, dividiéndolos en partes más pequeñas y manejables.

#### **Ejercicio 6: Calculadora de Áreas**

- **Concepto:** Divide y Vencerás.
- **Objetivo:** Crear varias funciones y llamarlas desde un menú principal.
- **Enunciado:**
  1.  Crea una función `double calcularAreaRectangulo(double base, double altura)`.
  2.  Crea una función `double calcularAreaCirculo(double radio)`. (Usa `Math.PI` para el valor de Pi).
  3.  Copia el ejercicio [B03.1.3](./B03.1.bucles.md#ejercicio-3-menú-de-opciones-sencillo) y modificalo creando funciones para cada uno de los cálculos (Área del cuadrado, triángulo y circulo)

#### **Ejercicio 7: Validando con `return` Temprano**

- **Concepto:** Salida temprana con `return` para mejorar la legibilidad.
- **Objetivo:** Utilizar `return` para salir de una función tan pronto como se conoce el resultado.
- **Enunciado:**
  1.  Crea una función `String obtenerCalificacion(double nota)` que devuelva un texto según la nota.
  2.  La lógica es: si la nota es menor que 5, es "Suspenso". Si es menor que 7, "Aprobado". Si es menor que 9, "Notable". Si no, "Sobresaliente".
  3.  Implementa esta lógica usando `return`s tempranos. Por ejemplo:
      ```java
      if (nota < 0 || nota > 10) {
          return "Nota inválida"; // Salimos inmediatamente
      }
      if (nota < 5) {
          return "Suspenso"; // Si entra aquí, ya no sigue
      }
      // ... y así sucesivamente
      ```
  4.  Este estilo evita anidar múltiples `if-else` y hace el código más plano y fácil de leer.
  5.  Prueba la función desde `main` con varias notas.

#### **Ejercicio 8: Comprobador de Números Primos**

- **Concepto:** Combinar funciones y lógica de bucles.
- **Objetivo:** Crear una función compleja que determine si un número es primo.
- **Enunciado:**
  1.  Copia el ejercicio [B03.1.3](./B03.1.bucles.md#ejercicio-6-comprobador-de-números-primos)
  2.  Crea una función `boolean esPrimo(int numero)`.
  3.  Utiliza esta función para saber si el número es primo o no.

#### **Ejercicio 9: Conversor de Temperatura**

- **Concepto:** Llamar a una función desde otra.
- **Objetivo:** Demostrar cómo los métodos pueden colaborar entre sí.
- **Enunciado:**
  1.  Crea una función `double celsiusAFahrenheit(double celsius)`. La fórmula es `(celsius * 9/5) + 32`.
  2.  Crea una función `double fahrenheitACelsius(double fahrenheit)`. La fórmula es `(fahrenheit - 32) * 5/9`.
  3.  Crea un procedimiento `void mostrarTemperaturasEquivalentes(double celsius)` que reciba una temperatura en Celsius, la imprima, llame a `celsiusAFahrenheit` para convertirla, e imprima el resultado en Fahrenheit.
  4.  Desde `main`, llama a `mostrarTemperaturasEquivalentes` con un valor, por ejemplo, 25.0 grados.

---

### Nivel 3: Desafíos de Lógica

Estos ejercicios requieren pensar más en el algoritmo y en cómo dividirlo en las funciones correctas para que el código quede limpio y funcional.

#### **Ejercicio 10: ¿Es un Número Perfecto?**

- **Concepto:** Descomposición en funciones de ayuda (helper functions).
- **Objetivo:** Resolver un problema que se simplifica enormemente al usar una función auxiliar.
- **Enunciado:** Un número es "perfecto" si la suma de sus divisores propios (todos sus divisores excepto él mismo) es igual al propio número. Por ejemplo, 6 es perfecto porque sus divisores propios son 1, 2 y 3, y 1 + 2 + 3 = 6.
  1.  **Función de Ayuda:** Primero, crea una función `int sumarDivisoresPropios(int numero)`. Esta función debe encontrar todos los divisores de `numero` (desde 1 hasta `numero / 2`) y devolver su suma.
  2.  **Función Principal:** Luego, crea una función `boolean esPerfecto(int numero)`. Esta función será muy simple: debe llamar a `sumarDivisoresPropios(numero)` y devolver `true` si el resultado es igual a `numero`, y `false` en caso contrario.
  3.  Desde `main`, prueba la función `esPerfecto` con números como 6, 28 y 12.

#### **Ejercicio 11: La Serie de Fibonacci**

- **Concepto:** Algoritmos iterativos en una función.
- **Objetivo:** Implementar una secuencia matemática conocida dentro de una función.
- **Enunciado:**
  1.  Crea una función `int obtenerFibonacci(int posicion)` que devuelva el número de Fibonacci en una posición dada. La serie empieza con 0 y 1. Cada número siguiente es la suma de los dos anteriores (0, 1, 1, 2, 3, 5, 8, ...).
  2.  `obtenerFibonacci(0)` debería devolver 0. `obtenerFibonacci(1)` debería devolver 1. `obtenerFibonacci(6)` debería devolver 8.
  3.  **Pista:** Necesitarás un bucle y tres variables: una para el número anterior, una para el actual y una para guardar la suma temporalmente mientras iteras.
  4.  Maneja los casos base (posiciones 0 y 1) con un `if` al principio.

