# UT3. Bloque 6. üì¶ Paquetes 

| Resultados Aprendizaje | CE |
| ----------------------------------- | ----------- |
| RA3             | CE3a, CE3b, CE3c, CE3d, CE3e, CE3f, CE3g, CE3h, CE3i |

## Construyendo Nuestra Propia Librer√≠a de Utilidades

**Objetivo:** Aprender a organizar nuestro c√≥digo en paquetes de una forma progresiva y realista, reutilizando el trabajo que ya hemos hecho en ejercicios anteriores.

---

### **Ejercicio 1: üèóÔ∏è ¬°Construyendo los Cimientos! La Estructura de Paquetes**

**Contexto:** Antes de escribir una sola l√≠nea de c√≥digo para nuestra librer√≠a, necesitamos el "edificio" donde vivir√°. En programaci√≥n, ese edificio son las carpetas que forman los paquetes. Vamos a crear una estructura profesional.

**Tu Misi√≥n:**
1.  Abre tu proyecto de Java y ve a la carpeta principal de c√≥digo fuente (normalmente llamada `src`).
2.  Dentro de `src`, crea la siguiente estructura de carpetas, una dentro de la otra:
    *   Una carpeta llamada `com`.
    *   Dentro de `com`, una carpeta llamada `miproyecto`.
    *   Y finalmente, dentro de `miproyecto`, crea **dos carpetas**:
        *   `main` (Aqu√≠ vivir√° nuestro programa principal que se podr√° ejecutar).
        *   `utilidades` (Aqu√≠ guardaremos todas nuestras herramientas reutilizables).

**Verificaci√≥n:** Al final, tu estructura de carpetas dentro de `src` deber√≠a verse as√≠:
```
src/
‚îî‚îÄ‚îÄ com/
    ‚îî‚îÄ‚îÄ miproyecto/
        ‚îú‚îÄ‚îÄ main/
        ‚îî‚îÄ‚îÄ utilidades/
```
---

### **Ejercicio 2: üî¢ La Caja de Herramientas Matem√°ticas**

**Contexto:** ¬øRecuerdas todas esas funciones matem√°ticas √∫tiles que has creado (`esPrimo`, `factorial`, `sumarHasta`)? En lugar de tenerlas esparcidas o copiarlas y pegarlas, vamos a centralizarlas en un √∫nico lugar.

**Tu Misi√≥n:**
1.  Dentro de la carpeta `.../utilidades/` que creaste en el paso anterior, crea un nuevo fichero de Java llamado `Matematicas.java`.
2.  Lo **primero** que debes escribir en este fichero es la declaraci√≥n del paquete. Esto le dice a Java d√≥nde vive este fichero:
    ```java
    package com.miproyecto.utilidades;
    ```
3.  Ahora, crea la clase p√∫blica `Matematicas`.
4.  Busca en tus ejercicios anteriores las siguientes funciones y **mu√©velas** (corta y pega) dentro de la clase `Matematicas`. Aseg√∫rate de que todas sean `public static`:
    *   `public static boolean esPrimo(int numero)`
    *   `public static int factorial(int numero)`
    *   `public static int sumarHasta(int numero)` (si no la tienes creal√°)
    *   `public static int encontrarMaximo(int a, int b)`

**Verificaci√≥n:** Tu fichero `Matematicas.java` deber√≠a empezar con la l√≠nea `package...` y contener una clase con al menos cuatro m√©todos est√°ticos y p√∫blicos.

---

### **Ejercicio 3: üöÄ ¬°Manos a la Obra! Usando Nuestras Utilidades**

**Contexto:** De nada sirve tener una caja de herramientas si no la usamos. Ahora crearemos un programa principal que "importar√°" y utilizar√° nuestra nueva librer√≠a de matem√°ticas.

**Tu Misi√≥n:**
1.  Navega a la carpeta `.../main/` que creaste en el primer ejercicio.
2.  Crea un nuevo fichero de Java llamado `Principal.java`.
3.  Como siempre, declara su paquete al principio del todo:
    ```java
    package com.miproyecto.main;
    ```
4.  Ahora viene la magia. Para poder "ver" las herramientas del otro paquete, necesitas **importarlas**. Justo debajo de la l√≠nea del `package`, a√±ade:
    ```java
    import com.miproyecto.utilidades.Matematicas;
    ```
5.  Crea tu clase `Principal` con su m√©todo `main`.
6.  Dentro del `main`, ¬°utiliza tus herramientas! Llama a las funciones del paquete de utilidades anteponiendo el nombre de la clase:
    ```java
    public static void main(String[] args) {
        int num = 7;
        boolean primo = Matematicas.esPrimo(num);
        System.out.println("¬øEl n√∫mero " + num + " es primo? " + primo);

        int fact = 5;
        int resultadoFactorial = Matematicas.factorial(fact);
        System.out.println("El factorial de " + fact + " es: " + resultadoFactorial);
    }
    ```
7.  Compila y ejecuta tu fichero `Principal.java`. Si todo est√° correcto, deber√≠as ver los resultados en la consola. ¬°Acabas de hacer que dos partes de tu proyecto separadas f√≠sicamente colaboren!

---

### **Ejercicio 4: ‚úçÔ∏è Ampliando la Librer√≠a con Utilidades de Texto**

**Contexto:** Nuestro proyecto crece, y ahora no solo necesitamos c√°lculos matem√°ticos, sino tambi√©n herramientas para manipular texto. ¬°Vamos a ampliar nuestra librer√≠a!

**Tu Misi√≥n:**
1.  Vuelve a la carpeta `.../utilidades/`.
2.  Crea un nuevo fichero llamado `Cadenas.java`.
3.  A√±ade la declaraci√≥n del paquete al principio (`package com.miproyecto.utilidades;`).
4.  Crea la clase p√∫blica `Cadenas`.
5.  Busca en tus ejercicios anteriores las funciones que trabajaban con texto y mu√©velas aqu√≠. Aseg√∫rate de que sean `public static`:
    *   `public static boolean esPalindromo(String texto)`
    *   `public static int contarCaracter(String texto, char caracter)`
    *   `public static char obtenerPrimeraLetra(String texto)`

**Verificaci√≥n:** Ahora, tu carpeta `utilidades` contiene dos ficheros: `Matematicas.java` y `Cadenas.java`, cada uno con su conjunto de herramientas especializadas.

---

### **Ejercicio 5: üß© El Programa Final: Combinando Todo**

¬°Excelente apunte! Es crucial adaptar los ejercicios al conocimiento exacto de los alumnos. Tienes toda la raz√≥n, si no han visto arrays, el m√©todo `split()` est√° fuera de los l√≠mites. Esto hace que el ejercicio sea a√∫n m√°s interesante, ya que les obliga a trabajar con los `String` a un nivel m√°s fundamental.

Aqu√≠ tienes la versi√≥n corregida del ejercicio final, completamente libre de arrays, que obliga a los alumnos a usar manipulaci√≥n de cadenas por posiciones.

---

### üïµÔ∏è‚Äç‚ôÇÔ∏è El Desaf√≠o Final: El Analista de C√≥digos Secretos

**Contexto:**
¬°Felicidades, programador! Has sido reclutado por la "Agencia de Criptograf√≠a y L√≥gica Aplicada" (ACLA) por tu habilidad para crear herramientas de software robustas. Tu primera misi√≥n es crear el programa de consola principal para analizar la validez de los c√≥digos de nuestros agentes.

Este programa deber√° combinar tus librer√≠as de `Matematicas` y `Cadenas` para realizar an√°lisis complejos, pero con una restricci√≥n clave: **no puedes usar arrays de ning√∫n tipo.**

---

#### **Paso 1 y 2: Preparaci√≥n y Men√∫**

Estos pasos iniciales permanecen exactamente iguales. Debes tener tu clase `Principal` con los `import` necesarios (incluyendo el `Scanner`) y el esqueleto del men√∫ con el bucle `do-while` y el `switch`.

```java
// EN: com/miproyecto/main/Principal.java
package com.miproyecto.main;

import com.miproyecto.utilidades.Matematicas;
import com.miproyecto.utilidades.Cadenas;
import java.util.Scanner;

public class Principal {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int opcion;

        do {
            // ... (el c√≥digo del men√∫ que ya ten√≠as) ...
            switch (opcion) {
                case 1:
                    System.out.print("Introduzca el c√≥digo de campo (ej: ANA-7): ");
                    String codigo = scanner.nextLine();
                    if (verificarCodigoCampo(codigo)) {
                        System.out.println("Analizando... El c√≥digo de campo '" + codigo + "' es: V√ÅLIDO");
                    } else {
                        System.out.println("Analizando... El c√≥digo de campo '" + codigo + "' es: INV√ÅLIDO");
                    }
                    break;
                case 2:
                    // ... (la l√≥gica para la misi√≥n 2) ...
                    break;
                // ... (el resto del switch) ...
            }
        } while (opcion != 0);
        
        scanner.close();
    }
    
    // Aqu√≠ ir√°n las nuevas funciones...
}
```
---

#### **Paso 3: Misi√≥n 1 - El Verificador de 'C√≥digo de Campo' üîç**

Un "C√≥digo de Campo" v√°lido para un agente sigue estas reglas:
1.  El c√≥digo tiene el formato `NOMBRE-CLAVE`.
2.  La parte `NOMBRE` debe ser un pal√≠ndromo.
3.  La parte `CLAVE` (un n√∫mero) debe ser un n√∫mero primo.

**Tu Tarea:**
Crea una nueva funci√≥n `verificarCodigoCampo` dentro de tu clase `Principal` que resuelva este problema **sin usar `split()` ni arrays**.

```java
public static boolean verificarCodigoCampo(String codigo) {
    // ... Tu l√≥gica va aqu√≠ ...
}
```

> **üí° Pistas Cruciales (¬°La Nueva Estrategia!):**
> 1.  **Encuentra el Guion:** Para separar el nombre y la clave, primero necesitas saber d√≥nde est√° el guion. El m√©todo `codigo.indexOf('-')` te dar√° la posici√≥n exacta del guion como un n√∫mero `int`.
> 2.  **Maneja C√≥digos Inv√°lidos:** ¬øQu√© pasa si no hay guion? `indexOf` devolver√° `-1`. Si eso ocurre, el formato es incorrecto y la funci√≥n deber√≠a devolver `false` inmediatamente.
> 3.  **Extrae las Partes con `substring`:** Una vez que tienes la posici√≥n del guion, puedes "cortar" el string en dos partes:
>     *   El `NOMBRE` es la subcadena desde el inicio (posici√≥n 0) hasta la posici√≥n del guion. La llamada ser√≠a: `codigo.substring(0, posicionDelGuion)`.
>     *   La `CLAVE` es la subcadena desde la posici√≥n *siguiente* al guion hasta el final del string. La llamada ser√≠a: `codigo.substring(posicionDelGuion + 1)`.
> 4.  **¬°Agente, prep√°rese para lo inesperado!** ¬øQu√© pasa si el c√≥digo es `ANA-TEXTO`? La conversi√≥n del n√∫mero fallar√°. Para ser un agente robusto, debe rodear la parte de la conversi√≥n del n√∫mero y la llamada a `esPrimo` con un bloque **`try-catch (Exception e)`**. Si el c√≥digo salta al `catch`, significa que el formato era incorrecto (la clave no era un n√∫mero), por lo que la funci√≥n deber√≠a devolver `false`.
> 5.  **Combina las Llamadas:** Con las dos partes ya extra√≠das y la clave convertida a `int`, llama a `Cadenas.esPalindromo()` y `Matematicas.esPrimo()` para verificar si ambas condiciones se cumplen.

---

#### **Paso 4: Misi√≥n 2 - El 'Nivel de Complejidad'**

Esta misi√≥n no requiere arrays, por lo que su planteamiento original sigue siendo perfectamente v√°lido.

1.  **Mejora tu librer√≠a:** Aseg√∫rate de que tu clase `Cadenas.java` tiene la funci√≥n `public static int contarVocales(String texto)`.
2.  **Crea la funci√≥n combinada:** En tu clase `Principal`, crea la funci√≥n `calcularNivelComplejidad(String mensaje)` que llama a `contarVocales` y luego a `Matematicas.factorial` con el resultado. Usa `long` para el valor de retorno.

**Integraci√≥n:**
Dentro del `case 2:` de tu `switch`, pide al usuario un mensaje, llama a tu funci√≥n `calcularNivelComplejidad` e imprime el resultado.

---

### Soluci√≥n de Referencia para `verificarCodigoCampo`

Aqu√≠ tienes un ejemplo de c√≥mo podr√≠a quedar la funci√≥n m√°s desafiante para que tengas una referencia:

```java
public static boolean verificarCodigoCampo(String codigo) {
    // 1. Encontrar la posici√≥n del guion
    int posGuion = codigo.indexOf('-');

    // 2. Si no hay guion, el formato es incorrecto
    if (posGuion == -1) {
        return false;
    }

    // 3. Extraer las dos partes usando substring
    String nombre = codigo.substring(0, posGuion);
    String claveStr = codigo.substring(posGuion + 1);

    // 4. Verificar si el nombre es un pal√≠ndromo
    boolean nombreValido = Cadenas.esPalindromo(nombre);

    // Si el nombre ya no es v√°lido, no hace falta seguir calculando
    if (!nombreValido) {
        return false;
    }

    // 5. Verificar si la clave es un n√∫mero primo (con control de errores)
    try {
        int claveNum = Integer.parseInt(claveStr);
        boolean claveValida = Matematicas.esPrimo(claveNum);
        // La funci√≥n devuelve true solo si ambas partes son v√°lidas
        return claveValida; 
    } catch (NumberFormatException e) {
        // Si parseInt falla, la clave no era un n√∫mero. El c√≥digo es inv√°lido.
        return false;
    }
}
```