# UT02. Bloque 3. Ejercicios: Trabajo con bucles

Un bucle es una de las estructuras más potentes en programación. Nos permite ejecutar un bloque de código múltiples veces mientras se cumpla una condición. Esto nos ahorra escribir la misma línea de código cien veces y nos permite resolver problemas complejos con muy pocas líneas.

Hoy nos centraremos en dos tipos de bucles de condición: `while` y `do-while`.

1.  **El Bucle `while` (Mientras...)**:
    *   **Cómo funciona**: Es como un guardia de seguridad muy estricto. Primero, comprueba una condición. Si es verdadera, te deja pasar y ejecutar el código de su interior. Después de ejecutarlo, vuelve a la puerta y comprueba la condición de nuevo. Repetirá este proceso hasta que la condición sea falsa, momento en el que te dirá "no puedes pasar" y el programa continuará con lo que venga después del bucle.
    *   **La regla de oro**: Si la condición es falsa desde el principio, el código del interior del `while` **nunca se ejecutará**.

2.  **El Bucle `do-while` (Hacer... Mientras...)**:
    *   **Cómo funciona**: Es un guardia más confiado. Te dice: "pasa y haz lo tuyo una vez". Después de que hayas ejecutado el código interior por primera vez, se pone a comprobar la condición. Si es verdadera, te dice "vuelve a hacerlo". Repetirá este proceso hasta que la condición sea falsa.
    *   **La regla de oro**: El código de un `do-while` **siempre se ejecuta al menos una vez**, sin importar la condición.

La diferencia es sutil pero crucial. Usa `while` cuando no estés seguro de si necesitas ejecutar el código ni una sola vez. Usa `do-while` cuando sepas que, como mínimo, la acción debe realizarse una vez (como mostrar un menú).

---

### **Nivel Fácil**

#### **Ejercicio 1: Adivina el Dado**

**Objetivo:** Crear un juego simple que combine un bucle `do-while`, la entrada del usuario y un número aleatorio.

**Enunciado:** Escribe un programa que simule el lanzamiento de un dado de 6 caras. El programa generará un número aleatorio del 1 al 6 y le pedirá al usuario que adivine cuál es. El bucle debe continuar pidiendo un número hasta que el usuario acierte. Al final, felicita al jugador.

**Pistas:**
    *   Genera el número secreto *antes* de que empiece el bucle.
    *   Usa un `do-while` para asegurarte de que el jugador pueda intentarlo al menos una vez.
    *   La condición del bucle será seguir mientras el `numeroDelUsuario` sea diferente del `numeroSecreto`.
    *   
**Resultado Esperado (ejemplo):**
    
```
He lanzado un dado de 6 caras... ¡Intenta adivinar el número!
Tu intento: 4
¡Incorrecto! Prueba otra vez.
Tu intento: 2
¡Incorrecto! Prueba otra vez.
Tu intento: 5
¡Felicidades! ¡Has adivinado el número!
```

#### **Ejercicio 2: Lluvia de Números Positivos**

*   **Objetivo:** Usar un bucle `while` cuya condición dependa del valor generado aleatoriamente.
*   **Enunciado:** Crea un programa que genere números enteros aleatorios entre -10 y 20. El programa debe mostrar cada número generado y detenerse en el momento en que genere el primer número negativo. Al final, debe indicar cuántos números positivos (o cero) se generaron antes de parar.
*   **Pistas:**
    *   Puedes usar un bucle `while(true)` y una sentencia `break` dentro de un `if` para salir del bucle cuando se cumpla la condición.
    *   Necesitarás un contador para los números positivos.
    *   El rango de -10 a 20 tiene 31 números en total. `rand.nextInt(31) - 10`.
*   **Resultado Esperado (ejemplo):**
    ```
    Generando números...
    15
    8
    0
    19
    2
    -5
    ¡Se ha generado un número negativo!
    Se generaron 5 números positivos o cero.
    ```

#### **Ejercicio 3: Calculadora de Hipotenusas**

*   **Objetivo:** Practicar el uso de `Math.sqrt()` y `Math.pow()` dentro de un bucle controlado por el usuario.
*   **Enunciado:** Escribe un programa que calcule la hipotenusa de un triángulo rectángulo. El programa generará aleatoriamente dos catetos (lados `a` y `b`) con valores entre 1 y 50. Mostrará los catetos generados, calculará y mostrará la hipotenusa. Después, preguntará al usuario si desea calcular otra. El programa se repetirá hasta que el usuario responda "no".
*   **Pistas:**
    *   La fórmula es `h = √(a² + b²)`.
    *   Usa `Math.pow(base, exponente)` para las potencias y `Math.sqrt(numero)` para la raíz cuadrada.
    *   Un bucle `do-while` es ideal para este menú de "repetir o salir".
*   **Resultado Esperado (ejemplo):**
    ```
    --- Calculando Hipotenusa ---
    Cateto A: 25.0
    Cateto B: 42.0
    La hipotenusa es: 48.87739764013996
    
    ¿Deseas calcular otra? (si/no): si
    --- Calculando Hipotenusa ---
    Cateto A: 10.0
    Cateto B: 15.0
    La hipotenusa es: 18.027756377319946
    
    ¿Deseas calcular otra? (si/no): no
    ¡Hasta la próxima!
    ```

#### **Ejercicio 4: Maestro del Redondeo**

*   **Objetivo:** Comprender las diferencias entre `Math.round()`, `Math.ceil()` y `Math.floor()`.
*   **Enunciado:** Crea un programa que genere 5 números `double` aleatorios entre 0.0 y 100.0. Por cada número generado, el programa debe mostrar el número original y su valor redondeado de tres formas: al entero más cercano (`round`), redondeado siempre hacia arriba (`ceil`) y redondeado siempre hacia abajo (`floor`).
*   **Pistas:**
    *   Usa un bucle `while` con un contador que vaya de 0 a 4 (o de 1 a 5).
    *   Para generar un `double` aleatorio, puedes usar `rand.nextDouble() * 100`.
*   **Resultado Esperado (ejemplo):**
    ```
    --- Demostración de Redondeo ---
    Número Original: 83.754
    Round: 84 | Ceil: 84.0 | Floor: 83.0
    
    Número Original: 22.198
    Round: 22 | Ceil: 23.0 | Floor: 22.0
    
    ... (y así 3 veces más) ...
    ```

---

### **Nivel Intermedio**

#### **Ejercicio 5: Carrera Aleatoria**

*   **Objetivo:** Simular un proceso competitivo gestionando el estado de múltiples variables dentro de un bucle.
*   **Enunciado:** Simula una carrera entre dos corredores, "Rayo" y "Veloz". La carrera tiene 100 metros. En cada "segundo" (cada iteración del bucle), cada corredor avanza una distancia aleatoria entre 1 y 10 metros. Muestra el progreso de ambos en cada segundo. El bucle termina cuando uno de los corredores (o ambos) cruza la meta. Al final, declara al ganador.
*   **Pistas:**
    *   Necesitarás una variable para la posición de "Rayo" y otra para "Veloz", ambas inicializadas a 0.
    *   El bucle `while` debe continuar mientras `posicionRayo < 100 && posicionVeloz < 100`.
    *   Después del bucle, usa un `if/else if/else` para determinar quién ganó o si hubo un empate.
*   **Resultado Esperado (ejemplo):**
    ```
    Segundo 1: Rayo (8m) | Veloz (5m)
    Segundo 2: Rayo (15m) | Veloz (15m)
    Segundo 3: Rayo (25m) | Veloz (18m)
    ...
    Segundo 11: Rayo (98m) | Veloz (102m)
    ¡La carrera ha terminado!
    ¡El ganador es Veloz!
    ```

#### **Ejercicio 6: Búsqueda del Tesoro 2D**

*   **Objetivo:** Aplicar la fórmula de la distancia euclidiana y guiar al usuario en un espacio de dos dimensiones.
*   **Enunciado:** El programa esconderá un tesoro en una coordenada `(x, y)` aleatoria, con valores entre -20 y 20 para cada eje. El jugador empieza en `(0,0)`. En cada turno, el programa le dirá al jugador la distancia exacta que le separa del tesoro y le pedirá que introduzca su siguiente movimiento en `x` y en `y`. El juego termina cuando el jugador está a una distancia de 1.0 o menos del tesoro.
*   **Pistas:**
    *   Fórmula de la distancia: `dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))`.
    *   Usa un bucle `do-while` que continúe mientras la `distancia > 1.0`.
    *   Necesitarás variables para la posición actual del jugador (`jugadorX`, `jugadorY`) y para las del tesoro (`tesoroX`, `tesoroY`).
*   **Resultado Esperado (ejemplo):**
    ```
    ¡El tesoro está escondido! Estás en la posición (0, 0).
    La distancia al tesoro es: 14.866
    Introduce tu movimiento en X: 10
    Introduce tu movimiento en Y: 10
    
    Ahora estás en (10, 10). La distancia al tesoro es: 4.123
    Introduce tu movimiento en X: 2
    Introduce tu movimiento en Y: -1
    
    Ahora estás en (12, 9). La distancia al tesoro es: 0.8
    ¡Enhorabuena! ¡Has encontrado el tesoro!
    ```

#### **Ejercicio 7: La Racha de Monedas**

*   **Objetivo:** Resolver un problema que no tiene un número fijo de iteraciones, rastreando un estado consecutivo.
*   **Enunciado:** Simula el lanzamiento de una moneda. El programa debe seguir lanzando la moneda hasta que salgan 3 "Caras" seguidas. Debe imprimir el resultado de cada lanzamiento ("Cara" o "Cruz") y al final indicar cuántos lanzamientos totales fueron necesarios.
*   **Pistas:**
    *   Usa `rand.nextInt(2)` para simular la moneda (0 = Cara, 1 = Cruz).
    *   Necesitarás un contador de lanzamientos totales y otro para las caras consecutivas.
    *   Si sale "Cara", incrementa el contador de racha. Si sale "Cruz", reinícialo a 0.
    *   El bucle `while` debe continuar mientras `rachaDeCaras < 3`.
*   **Resultado Esperado (ejemplo):**
    ```
    Lanzamiento 1: Cruz
    Lanzamiento 2: Cara
    Lanzamiento 3: Cruz
    Lanzamiento 4: Cara
    Lanzamiento 5: Cara
    Lanzamiento 6: Cruz
    Lanzamiento 7: Cara
    Lanzamiento 8: Cara
    Lanzamiento 9: Cara
    ¡Conseguido! Se necesitaron 9 lanzamientos para obtener 3 caras seguidas.
    ```

#### **Ejercicio 8: Simulador de Inversión Variable**

*   **Objetivo:** Modelar un sistema simple a lo largo del tiempo, introduciendo una fluctuación aleatoria.
*   **Enunciado:** Crea un programa que simule una inversión. El usuario introduce un capital inicial, un número de años y una tasa de interés anual base (ej. 5 para 5%). Cada año, el interés real fluctuará aleatoriamente: será la tasa base +/- 2% (ej. si la base es 5%, el interés anual real estará entre 3% y 7%). El programa debe mostrar el capital total al final de cada año.
*   **Pistas:**
    *   El interés real de cada año se puede calcular como `tasaBase + (rand.nextDouble() * 4 - 2)`.
    *   Usa un bucle `while` que se ejecute el número de años especificado.
    *   El capital del año siguiente es `capitalActual * (1 + interesReal / 100)`.
*   **Resultado Esperado (ejemplo):**
    ```
    Capital inicial: 1000.0 | Años: 5 | Tasa base: 5.0%
    
    Año 1: Interés real: 6.23%. Capital: 1062.30
    Año 2: Interés real: 3.89%. Capital: 1103.68
    Año 3: Interés real: 4.55%. Capital: 1153.90
    Año 4: Interés real: 5.12%. Capital: 1212.96
    Año 5: Interés real: 3.01%. Capital: 1249.47
    
    Tras 5 años, tu capital final es: 1249.47
    ```

#### **Ejercicio 9: Generador de Contraseñas Seguras**

*   **Objetivo:** Construir una cadena de texto (`String`) de forma iterativa utilizando caracteres aleatorios.
*   **Enunciado:** Escribe un programa que genere una contraseña aleatoria de la longitud que elija el usuario. La contraseña debe estar formada por letras minúsculas, mayúsculas y números.
*   **Pistas:**
    *   Define un `String` con todos los caracteres posibles: `String CARACTERES = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";`
    *   Usa un bucle que se repita tantas veces como la longitud deseada.
    *   En cada iteración, elige un carácter aleatorio del `String CARACTERES`. Puedes hacerlo generando un índice aleatorio con `rand.nextInt(CARACTERES.length())` y luego obteniendo el carácter con `CARACTERES.charAt(indice)`.
    *   Ve añadiendo cada nuevo carácter a un `String` que será tu contraseña final.
*   **Resultado Esperado (ejemplo):**
    ```
    Introduce la longitud deseada para la contraseña: 12
    Tu contraseña generada es: aK8xP4zW7qR2
    ```

---

### **Nivel Avanzado**

#### **Ejercicio 10: Combate por Turnos**

*   **Objetivo:** Crear un juego completo con múltiples variables de estado, varias condiciones aleatorias por turno y una narrativa clara.
*   **Enunciado:** Simula un combate por turnos entre un "Héroe" y un "Monstruo".
    *   Ambos empiezan con 100 puntos de vida (HP).
    *   El combate continúa hasta que uno de los dos tenga 0 HP o menos.
    *   En cada turno, ataca primero el Héroe y luego el Monstruo.
    *   **Ataque del Héroe:** Daño base aleatorio entre 10 y 20. Hay un 20% de probabilidad de que sea un "Golpe Crítico" (el daño se duplica).
    *   **Ataque del Monstruo:** Daño base aleatorio entre 5 y 25. Hay un 10% de probabilidad de que el Héroe "Esquive" el ataque (no recibe daño).
    *   El programa debe narrar cada acción y mostrar los puntos de vida restantes después de cada turno. Al final, debe declarar un ganador.
*   **Pistas:**
    *   El bucle principal debe ser `while (hpHeroe > 0 && hpMonstruo > 0)`.
    *   Para la probabilidad, usa `rand.nextDouble()`. Por ejemplo, para un 20% de probabilidad, la condición es `if (rand.nextDouble() < 0.20)`.
    *   Usa `Math.max(0, vidaActual)` para asegurarte de que la vida no se muestre como un número negativo al final.
*   **Resultado Esperado (ejemplo):**
    ```
    ¡COMIENZA EL COMBATE! (Héroe: 100 HP | Monstruo: 100 HP)
    
    --- Turno 1 ---
    ¡El Héroe ataca! ¡Es un GOLPE CRÍTICO! Causa 36 de daño.
    El Monstruo contraataca y causa 18 de daño.
    (Héroe: 82 HP | Monstruo: 64 HP)
    
    --- Turno 2 ---
    El Héroe ataca y causa 12 de daño.
    ¡El Héroe ESQUIVA el ataque del Monstruo!
    (Héroe: 82 HP | Monstruo: 52 HP)
    
    ... (varios turnos después) ...
    
    --- Turno 7 ---
    El Héroe ataca y causa 19 de daño.
    (Héroe: 25 HP | Monstruo: 0 HP)
    
    ¡El Monstruo ha sido derrotado! ¡VICTORIA PARA EL HÉROE!
    ```