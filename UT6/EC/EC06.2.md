# ğŸ° EC06.2 Profundizando en la POO

Â¡Nuestros hÃ©roes van tomando forma! Pero un buen motor de videojuego necesita ser robusto. 
En esta hoja de ejercicios vamos a profesionalizar nuestro cÃ³digo. Aprenderemos a proteger los datos, a gestionar la creaciÃ³n de objetos de forma flexible y a dar los primeros pasos en la herencia.

> Crea un nuevo proyecto en tu IDE y copia el cÃ³digo de la actividad EC06.1.

---

## ğŸ›¡ï¸ Ejercicio 1: La Muralla (Encapsulamiento y `this`)
*Protegiendo el nÃºcleo de nuestros hÃ©roes.*

**Problema:** Ahora mismo, cualquiera puede hacer `gandalf.salud = -5000;` desde el `Main`. Â¡Eso rompe el juego! Un hÃ©roe no deberÃ­a tener salud negativa arbitraria sin control.

### ğŸ“ Tu tarea:
1. Modifica la clase `Heroe`. Cambia la visibilidad de `nombre`, `nivel`, `salud` y `rol` a `private`.
   - *Intenta acceder a ellos desde el Main. Â¿QuÃ© pasa? (Spoiler: Error ğŸ›‘)*
2. Crea los mÃ©todos **Getters** y **Setters** para cada atributo.
   - `getNombre()`, `setNombre(String nombre)`, etc.
3. **Uso de `this`**: En tus setters, usa `this` para diferenciar el atributo de la clase del parÃ¡metro.
   ```java
   public void setNombre(String nombre) {
       this.nombre = nombre; // this.nombre es el atributo, nombre es el parÃ¡metro
   }
   ```
4. **LÃ³gica de protecciÃ³n**: En el mÃ©todo `setSalud(int salud)`, aÃ±ade una regla: 
   - Si la salud es menor que 0, asigna 0. (Â¡No permitimos muertos vivientes con salud negativa!).

---

## ğŸ”€ Ejercicio 2: Flexibilidad (Sobrecarga de Constructores)
*No siempre nacemos iguales.*

A veces queremos crear un hÃ©roe con todo detalle, pero otras veces queremos crear un "npc" rÃ¡pido y que el sistema rellene los datos por defecto.

### ğŸ“ Tu tarea:
1. MantÃ©n tu constructor actual (el que recibe todos los datos).
2. AÃ±ade un **segundo constructor** que solo reciba el `nombre`.
   - Este constructor asignarÃ¡ el nombre recibido.
   - Pero pondrÃ¡ valores por defecto a los demÃ¡s: `nivel = 1`, `salud = 100`, `rol = "Aldeano"`.
3. En el `Main`, crea un hÃ©roe usando este nuevo constructor y comprueba que sus datos por defecto son correctos.

> ğŸ’¡ Esto se llama **Sobrecarga**: Tener varios mÃ©todos (o constructores) con el mismo nombre pero diferentes parÃ¡metros.

---

## ğŸŒ Ejercicio 3: El Universo (Static y Propiedades Calculadas)
*Datos que pertenecen al mundo, no al individuo.*

Queremos saber cuÃ¡ntos hÃ©roes existen en total en nuestro juego. Este dato no pertenece a "Gandalf" ni a "Aragorn", pertenece al "Juego".

### ğŸ“ Tu tarea:
1. **Static**:
   - AÃ±ade un atributo `private static int contadorHeroes = 0;` en la clase `Heroe`.
   - Modifica **todos** los constructores para que, cada vez que se cree un hÃ©roe, sumen 1 a este contador (`contadorHeroes++`).
   - Crea un mÃ©todo `public static void imprimirInfoTecnica()` que muestre por consola: *"Total de hÃ©roes creados: X"*.
   - LlÃ¡malo desde el `Main` usando la clase, no el objeto: `Heroe.imprimirInfoTecnica();`.

2. **Propiedades Calculadas**:
   - A veces un dato no se guarda, se calcula.
   - Crea un mÃ©todo `public boolean estaVivo()`.
   - No necesitas un atributo `boolean vivo`. Simplemente devuelve `true` si `salud > 0` y `false` si no.
   - Ãšsalo en el `Main`: `if (gandalf.estaVivo()) ...`

---

## ğŸ‘¯ Ejercicio 4: Clones vs Gemelos (Identidad vs Igualdad)
*Â¿Somos el mismo o somos iguales?*

### ğŸ“ Tu tarea:
1. En el `Main`, crea dos hÃ©roes con **exactamente** los mismos datos (mismo nombre, salud, etc.). `h1` y `h2`.
2. CompÃ¡ralos con `if (h1 == h2)`.
   - Â¿QuÃ© sale? Â¿Por quÃ©? (Pista: `==` compara si son el **mismo objeto en memoria**).
3. Crea un mÃ©todo en `Heroe` llamado `public boolean esIgualA(Heroe otro)`.
   - Este mÃ©todo debe devolver `true` solo si el `nombre` y el `rol` son iguales.
   - Prueba ahora: `if (h1.esIgualA(h2))`. Â¡Ahora deberÃ­an ser "iguales" para tu juego!

---

## ğŸ‘‘ Ejercicio 5: Legado (Herencia)
*La especializaciÃ³n de la especie.*

Hasta ahora todos son "HÃ©roes". Pero un Mago es un HÃ©roe... con cosas extra.

### ğŸ“ Tu tarea:
1. Crea una nueva clase `Mago.java`.
2. Haz que herede de `Heroe` usando `extends`: `public class Mago extends Heroe`.
3. AÃ±ade un atributo propio a `Mago`: `private int mana`.
4. Crea un constructor para `Mago`.
   - **Ojo**: Lo primero que debe hacer un hijo es llamar al constructor del padre usando `super(nombre, ...)`.
5. En el `Main`:
   - Crea un objeto de tipo `Mago`.
   - Intenta llamar al mÃ©todo `presentarse()` (que estÃ¡ en Heroe). Â¡Funciona! Ha heredado el comportamiento.
   - Intenta acceder a `mana`. Solo el Mago lo tiene.


## âš”ï¸ Ejercicio 6: El Gran Duelo (DinÃ¡mica de Juego)
*Donde la teorÃ­a se convierte en acciÃ³n.*

Para terminar, vamos a hacer que nuestros hÃ©roes puedan interactuar entre sÃ­ en un combate a muerte por turnos.

### ğŸ“ Tu tarea:
1. **Preparar el combate**:
   - En la clase `Heroe`, aÃ±ade el mÃ©todo `public void recibirDaÃ±o(int cantidad)`. Resta la cantidad a la `salud`. Si la salud baja de 0, asegÃºrate de que se quede en 0.
   - AÃ±ade el mÃ©todo `public void atacar(Heroe enemigo)`. Dentro, genera un nÃºmero aleatorio de daÃ±o (por ejemplo, entre 10 y 30) y llama al mÃ©todo `enemigo.recibirDaÃ±o(daÃ±o)`. Muestra un mensaje: "*[Nombre] ataca a [Enemigo] y le quita [X] de vida*".

2. **El Bucle de Juego (Clase Main)**:
   - Crea dos personajes (ej: un `Heroe` guerrero y un `Mago`).
   - Usa un bucle `while` que continÃºe mientras **ambos** estÃ©n vivos (usa tu mÃ©todo `estaVivo()`).
   - Dentro del bucle:
     1. El primer hÃ©roe ataca al segundo.
     2. Si el segundo sigue vivo, el segundo ataca al primero.
     3. Muestra el estado de salud de ambos al final de cada turno.
   - Al salir del bucle, anuncia quiÃ©n ha ganado.

3. **Reto Pro**: Si el atacante es un `Mago`, haz que gaste 10 de `mana` por cada ataque, y si no tiene mana, que el daÃ±o sea mucho menor.

