# üèÜ Ejercicio B06.3: Liga de F√∫tbol Pro (Refactorizaci√≥n)

*Este ejercicio parte de la base del **EC06.3 Ejercicio 2 (La Quiniela 2.0)**, pero llevando la orientaci√≥n a objetos a un nivel m√°s profesional.*

## üìå Contexto

En el ejercicio anterior, los equipos eran simples `Strings`. En una aplicaci√≥n real, un equipo tiene m√°s datos (c√≥digo, estadio, plantilla...). Adem√°s, los partidos no est√°n "sueltos", sino que se agrupan en **Jornadas**, y todas las jornadas forman una **Liga**.

---

## üìù Tareas a realizar:

### 1. El modelo de datos

Crea las siguientes clases:

#### A. Clase `Equipo`

Representa a un equipo de f√∫tbol profesional.
- **Atributos**: `nombre` (String) y `codigo` (int).
- **Constructor** y **Getters**.

#### B. Clase `Partido` (Refactorizada)

Ahora los equipos son objetos, no textos.

- **Atributos**: `equipoLocal` (tipo `Equipo`), `equipoVisitante` (tipo `Equipo`), `golesLocal`, `golesVisitante` y `jugado`.
- **M√©todos**: Los mismos que en el ejercicio anterior (setResultado, toString, etc.).

#### C. Clase `Jornada`

Agrupa los partidos de una fecha concreta.

- **Atributos**: `numeroJornada` (int), `partidos` (Array de `Partido`)
- **Constante**: `NUM_PARTIDOS` (define cu√°ntos partidos hay por jornada, por ejemplo 10).
- **M√©todos**: 

- `generarPartidos(Liga liga)`: Este m√©todo debe obtener la lista de equipos de la liga y crear los objetos `Partido` correspondientes para esta jornada.
- `simularPartidos()`: Genera un resultado aleatorio para cada partido y asigna los goles a los equipos correspondientes.
- `imprimirJornada()`: Imprime la jornada con todos los partidos.
- `getPartidos()`: Devuelve el array de partidos.
- `getNumeroJornada()`: Devuelve el n√∫mero de la jornada.


### D. Clase `FilaClasificacion`

Para no romper la **Responsabilidad √önica** de la clase `Equipo`, crearemos esta clase "envoltorio". **Cada objeto `FilaClasificacion` est√° vinculado a un √∫nico `Equipo`** y guarda sus estad√≠sticas acumuladas en la liga.

- **Atributos**: `equipo` (tipo `Equipo`), `puntos`, `partidosJugados`, `golesFavor`, `golesContra`.
- **M√©todo**: `actualizarStats(int misGoles, int susGoles)`: 
    - Se invoca sobre la fila de un equipo concreto. 
    - `misGoles` son los goles marcados por el equipo de esta fila.
    - `susGoles` son los goles recibidos (marcados por el rival).
    - El m√©todo incrementa los puntos (3 si gana, 1 si empata, 0 si pierde) y actualiza los contadores de goles.

### E. Clase `Clasificaci√≥n`

Es la encargada de gestionar el array de todas las filas y de **hacer de puente** entre un partido y las estad√≠sticas.

- **Atributos**: `filas` (Array de `FilaClasificacion`).
- **M√©todos**: 
    - `actualizar(Partido p)`: 
        1. Obtiene el `Equipo Local` y `Equipo Visitante` del partido `p`.
        2. Busca en el array de `filas` qu√© objeto pertenece al local y cu√°l al visitante.
        3. Para el local, llama a `filaLocal.actualizarStats(p.getGolesL(), p.getGolesV())`.
        4. Para el visitante, llama a `filaVisitante.actualizarStats(p.getGolesV(), p.getGolesL())`.
    - `ordenar()`: (Privado)Ordena el array de filas por puntos (y goles diferencia si hay empates).<br>
       ‚ö° Investiga el algoritmo de ordenaci√≥n **Bubble Sort**, y aplicalo para ordenar el array de filas, y devolver el array ordenado.
    - `imprimirClasificacion()`: Imprime la tabla resumen (Antes de imprimir, ordena el array con `ordenar()`). Para optimizar, no vuelves a ordenar el array si ya est√° ordenado, debes usar una variable booleana `isOrdenado`.
    - `getFilas()`: Devuelve el array de filas.
    - `getEquipo(int codigo)`: Devuelve el equipo cuyo c√≥digo coincide con el del equipo pasado como par√°metro.


### F. Clase `Liga`

Es el contenedor global.

- **Atributos**: `equipos` (Array de `Equipo`) y `clasificacion` (tipo `Clasificacion`).
- **M√©todos**:
    - `getEquipos()`: Devuelve el array de equipos.
    - `getClasificacion()`: Devuelve el objeto clasificaci√≥n.
    - `imprimirLiga()`: Imprime la liga con todos los equipos.
    - `generarCalendario()`: Genera todas las jornadas de la liga.
    - `simularJornadas()`: Simula todas las jornadas de la liga, simulando los partidos y actualizando las estad√≠sticas. Este proceso obtendr√° todas las jornadas, por cada una llamar√° a `jornada.simularPartidos()`, y finalmente llamar√° a `clasificacion.actualizar(p)` para actualizar las estad√≠sticas de cada partido. 
    - `imprimirCalendario()`: Imprime el calendario de la liga.
    - `imprimirClasificacion()`: Imprime la clasificaci√≥n de la liga.
    - `imprimirLiga()`: Imprime la liga con todos los equipos.


---

## ‚öôÔ∏è El Reto: Generaci√≥n de la Liga

Para que el ejercicio sea funcional, necesitamos una forma de emparejar a los equipos. 

**¬øC√≥mo generar todas las jornadas?**  
Si tienes 5 equipos, habr√° 4 jornadas (ida). Una forma sencilla es usar el **Algoritmo de Rotaci√≥n**:

```java
Algoritmo GenerarCalendario(listaEquipos)
    N = longitud(listaEquipos)
    NumJornadas = N - 1
    PartidosPorJornada = N / 2

    Para jornada Desde 1 Hasta NumJornadas Hacer
        Imprimir "JORNADA " + jornada
        Para i Desde 0 Hasta PartidosPorJornada - 1 Hacer
            Local = listaEquipos[i]
            Visitante = listaEquipos[N - 1 - i]
            Imprimir Local + " vs " + Visitante
        Fin Para

        // Rotaci√≥n: El primer equipo (√≠ndice 0) se queda fijo.
        // El resto de los equipos rotan una posici√≥n.
        Ultimo = listaEquipos[N - 1]
        Para k Desde N - 1 Hasta 2 Hacer
            listaEquipos[k] = listaEquipos[k - 1]
        Fin Para
        listaEquipos[1] = Ultimo
    Fin Para
Fin Algoritmo
```
---

## üéØ Objetivo Final

En tu clase `Main`, debes:
1. Crear una `Liga` con 5 equipos.
2. Crear un array de 4 `Jornadas`.
3. Para cada jornada, llamar a `generarPartidos(liga)`.
4. Mostrar por pantalla el calendario completo de la liga.


> üí° **Reflexi√≥n**: F√≠jate c√≥mo ahora la `Jornada` no sabe qui√©nes son los equipos hasta que se los pide a la `Liga`. Hemos separado las responsabilidades de forma clara.
