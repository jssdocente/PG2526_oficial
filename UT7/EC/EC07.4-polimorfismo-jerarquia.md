# EC07.4 - Polimorfismo JerÃ¡rquico y Pattern Matching

**TemÃ¡tica**: Flota Estelar (Naves Espaciales) ðŸš€

En este ejercicio abordaremos uno de los conceptos mÃ¡s confusos pero poderosos de la POO: **la diferencia entre la Referencia (el mando) y el Objeto (la nave real)**. AprenderÃ¡s por quÃ© una variable de tipo Padre puede contener un objeto Hijo, pero no puede acceder a todos sus mÃ©todos directamente, y cÃ³mo Java moderno soluciona esto elegantemente.

---

## ðŸ§  TeorÃ­a: La MÃ¡scara del Tipo

Cuando escribes:
```java
Nave miNave = new Caza();
```

EstÃ¡s haciendo dos cosas:
1.  **Creas un Objeto `Caza`** en memoria (con todas sus armas y motores).
2.  **Usas una Referencia `Nave`** para controlarlo.

**El Problema**: Tu variable `miNave` es como un mando universal bÃ¡sico. Aunque estÃ©s apuntando a un caza de combate avanzado, el mando solo tiene los botones bÃ¡sicos de una `Nave` (como "volar"). No tiene el botÃ³n "disparar", aunque la nave real sÃ­ tenga los caÃ±ones.

Para pulsar el botÃ³n "disparar", necesitas "cambiar de mando" (Casting) o usar herramientas modernas de identificaciÃ³n (Pattern Matching).

---

## Ejercicio 1: La Flota Base ðŸ›¸

### Contexto
El Comando Estelar necesita gestionar el trÃ¡fico de naves. Todas las naves vuelan, pero lo hacen de forma diferente.

### Enunciado

1.  **Crea la clase abstracta `Nave`**:
    - Atributo: `String nombre`.
    - Constructor: Recibe el nombre.
    - MÃ©todo abstracto: `public abstract void mover();`.
    - MÃ©todo concreto: `public void comunicarse()` que imprima "[Nombre]: AquÃ­ nave, cambio.".

2.  **Crea dos clases hijas**:
    - **`Caza`** (extiende `Nave`):
        - Implementa `mover()`: imprime "Volando a velocidad de combate".
    - **`Carguero`** (extiende `Nave`):
        - Implementa `mover()`: imprime "Iniciando propulsores de carga pesada".

### Prueba Preliminar

En un `main`, crea un `Caza` y un `Carguero` usando referencias de tipo `Nave` y llama a `mover()`. Observa cÃ³mo se ejecuta la versiÃ³n del hijo (Polimorfismo).

```java
Nave n1 = new Caza("Ala-X");
n1.mover(); // Â¿QuÃ© imprime?
```

---

## Ejercicio 2: Capacidades Ãšnicas (La LimitaciÃ³n) ðŸ›‘

### Contexto
AquÃ­ es donde la jerarquÃ­a se pone interesante. Cada nave tiene funciones que la otra no tiene.

### Enunciado

1.  **AÃ±ade funcionalidad exclusiva al `Caza`**:
    - MÃ©todo `void disparar()`: imprime "Â¡Pew pew! Disparando lÃ¡seres.".

2.  **AÃ±ade funcionalidad exclusiva al `Carguero`**:
    - Atributo `int capacidadCarga`.
    - MÃ©todo `void cargarMaterial(int cantidad)`: imprime "Cargando [cantidad] toneladas.".

3.  **Intenta usarlas desde la referencia `Nave`**:
    - En tu `main`, intenta hacer `n1.disparar()`.
    - **Observa el error**: El compilador no te deja. Â¿Por quÃ©? Porque tu variable es de tipo `Nave`, y las naves genÃ©ricas no disparan.

---

## ðŸ§  TeorÃ­a: Casting de Objetos ðŸŽ­

Para solucionar el problema anterior, necesitamos decirle al compilador: *"Oye, confÃ­a en mÃ­, sÃ© que esta variable `Nave` contiene en realidad un `Caza`"*. Esto se llama **Casting**.

Existen dos tipos de movimientos en la jerarquÃ­a:

1.  **UPCASTING (Hacia arriba) â˜ï¸**
    - Tratar a un hijo como si fuera su padre.
    - **Es automÃ¡tico y seguro** (todo Caza ES una Nave).
    - `Nave n = new Caza();` âœ…

2.  **DOWNCASTING (Hacia abajo) â›ï¸**
    - Tratar a un padre como si fuera uno de sus hijos especÃ­ficos.
    - **Es manual y peligroso** (no toda Nave es un Caza).
    - Requiere sintaxis explÃ­cita: `(TipoHijo) variablePadre`.
    - `Caza c = (Caza) n;` âš ï¸

### ðŸ’¥ El peligro: ClassCastException
Si intentas forzar una realidad que no existe, el programa explota.

```java
Nave n = new Carguero(); // Upcasting (Bien)
Caza c = (Caza) n;       // Downcasting (MAL!! Un Carguero no es un Caza)
```

Esto compila (porque te creen), pero al ejecutarse lanzarÃ¡ `ClassCastException`.
**SoluciÃ³n**: Antes de hacer downcasting, SIEMPRE pregunta usando `instanceof`.

---

## Ejercicio 3: IdentificaciÃ³n Manual (La "Vieja Escuela") ðŸ•µï¸â€â™‚ï¸

### Contexto
Para usar las funciones especiales, histÃ³ricamente tenÃ­amos que verificar el tipo y luego hacer un "casting" (forzar el tipo).

### Enunciado
Crea una clase `TorreDeControl` con un mÃ©todo estÃ¡tico `inspeccionarNave(Nave n)`.

Debes implementar la siguiente lÃ³gica usando `instanceof` clÃ¡sico y casting explicito:

1.  Mueve la nave (comÃºn a todas).
2.  Si es un **Caza**, conviÃ©rtelo a variable `Caza` y dispara.
3.  Si es un **Carguero**, conviÃ©rtelo a variable `Carguero` y carga 50 toneladas.

```java
// Estilo ClÃ¡sico (Java antiguo)
public static void inspeccionarNave(Nave n) {
    n.comunicarse();
    
    if (n instanceof Caza) {
        Caza c = (Caza) n; // Casting explÃ­cito (peligroso si te equivocas)
        c.disparar();
    } else if (n instanceof Carguero) {
        Carguero car = (Carguero) n;
        car.cargarMaterial(50);
    }
}
```

> **ReflexiÃ³n**: Â¿Ves lo repetitivo que es definir una variable `c` solo para convertir `n`?

---

## Ejercicio 4: EvoluciÃ³n Moderna con Switch Pattern Matching ðŸš€

### Contexto
Desde Java 21, podemos usar `switch` directamente sobre tipos de objetos, eliminando la necesidad de `if-else` en cascada y castings manuales. Esto hace el cÃ³digo mucho mÃ¡s limpio y seguro.

### Enunciado

1.  Crea una nueva clase **`EstacionInteligente`**.
2.  Implementa un mÃ©todo `gestionarEntrada(Nave n)` usando **Switch Expressions con Pattern Matching**.
3.  La lÃ³gica debe ser:
    - Si es `Caza`: Disparar y ordenar patrulla.
    - Si es `Carguero`: Cargar material.
    - Si es `null`: Lanzar una alerta.
    - `default`: Solo mover la nave (para naves desconocidas futuras).

### CÃ³digo Sugerido (Java 21+)

```java
public void gestionarEntrada(Nave n) {
    switch (n) {
        case Caza c -> {
            System.out.println(">> Caza identificado.");
            c.disparar();
        }
        case Carguero car -> {
            System.out.println(">> Carguero en muelle.");
            car.cargarMaterial(100);
        }
        case null -> System.out.println("!! ALERTA: SeÃ±al fantasma (null) !!");
        default -> {
            System.out.println(">> Nave estÃ¡ndar.");
            n.mover();
        }
    }
}
```

### Prueba Final
En tu `main`, crea un array `Nave[] flota` con cazas, cargueros, y quizÃ¡s un `null`. PÃ¡salos todos por el mÃ©todo `gestionarEntrada`.

---

## ðŸŽ¯ DesafÃ­o Hacker: Comportamiento Condicional (Guards)

En Java moderno (Switch Pattern Matching), puedes aÃ±adir condiciones extra en el propio `case` (usando `when`).

**Objetivo**: Modifica el `switch` para que:
1.  Si es un `Carguero` con capacidad **mayor a 1000**, imprima "Carguero PESADO priorizado".
2.  Si es un `Carguero` normal, actÃºe normal.

*Investiga la sintaxis `case Carguero c when c.getCapacidad() > 1000 -> ...`*

---

## ðŸ“š Resumen de Conceptos

| Concepto | Variable (Mando) | Objeto (Realidad) |
| :--- | :--- | :--- |
| **DeclaraciÃ³n** | `Nave n` | `new Caza()` |
| **Lo que puedes llamar** | Solo mÃ©todos de `Nave` | MÃ©todos sobrescritos del `Caza` se ejecutan |
| **Para acceder al resto** | Necesitas Casting / Pattern Matching | Siempre tiene todo en memoria |
