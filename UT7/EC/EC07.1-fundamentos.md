# EC07.1 - Fundamentos de Herencia y Modelado

**Tem√°tica**: Sistema de Casa Inteligente (Dom√≥tica)

En esta serie de ejercicios construir√°s el n√∫cleo de un sistema de gesti√≥n para dispositivos IoT de una casa inteligente. Aprender√°s a modelar jerarqu√≠as de clases, usar abstracci√≥n y elegir entre tipos mutables e inmutables.

---

## Ejercicio 1: La Base del Sistema üè†

### Contexto
Toda casa inteligente necesita un sistema central que gestione sus dispositivos. Empezaremos creando la clase base que compartir√°n todos los dispositivos.

### Objetivo
Crear una jerarqu√≠a simple usando herencia y entender el uso de `super` en constructores.

### Enunciado

Crea las siguientes clases:

1. **Clase `Dispositivo`** (clase base):
   - Atributos privados:
     - `String nombre`
     - `String ubicacion` (ej: "Sal√≥n", "Cocina")
     - `boolean encendido`
   - Constructor que reciba nombre y ubicaci√≥n (por defecto, el dispositivo est√° apagado)
   - M√©todos p√∫blicos:
     - Getters para todos los atributos
     - `void encender()` y `void apagar()`
     - `String getEstado()` que devuelva "Encendido" o "Apagado"

2. **Clase `EnchufeInteligente`** que herede de `Dispositivo`:
   - Atributo adicional privado:
     - `double consumoWatts`
   - Constructor que reciba nombre, ubicaci√≥n y consumo
   - M√©todo adicional:
     - `double calcularConsumoHora()` que devuelva el consumo en Wh

### Diagrama de Clases

```mermaid
classDiagram
    class Dispositivo {
        -String nombre
        -String ubicacion
        -boolean encendido
        +Dispositivo(nombre, ubicacion)
        +encender()
        +apagar()
        +getEstado() String
    }
    
    class EnchufeInteligente {
        -double consumoWatts
        +EnchufeInteligente(nombre, ubicacion, consumo)
        +calcularConsumoHora() double
    }
    
    Dispositivo <|-- EnchufeInteligente
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio1 {
    public static void main(String[] args) {
        EnchufeInteligente enchufe = new EnchufeInteligente("Enchufe TV", "Sal√≥n", 150.0);
        
        System.out.println("Dispositivo: " + enchufe.getNombre());
        System.out.println("Estado: " + enchufe.getEstado());
        
        enchufe.encender();
        System.out.println("Estado tras encender: " + enchufe.getEstado());
        System.out.println("Consumo por hora: " + enchufe.calcularConsumoHora() + " Wh");
    }
}
```

**Salida esperada:**
```
Dispositivo: Enchufe TV
Estado: Apagado
Estado tras encender: Encendido
Consumo por hora: 150.0 Wh
```

> üí° **Pista: Uso de `super`**
>
> En el constructor de `EnchufeInteligente`, la primera l√≠nea debe ser:
> ```java
> super(nombre, ubicacion);
> ```
> Esto invoca al constructor de la clase padre `Dispositivo`.

---

## Ejercicio 2: Abstraer el Comportamiento üîå

### Contexto
No todos los dispositivos se conectan de la misma manera. Un termostato necesita calibrarse, un enchufe solo necesita activar el rel√©. Vamos a definir un contrato com√∫n.

### Objetivo
Convertir `Dispositivo` en una clase abstracta y obligar a las subclases a implementar su l√≥gica de conexi√≥n.

### Enunciado

1. **Modifica la clase `Dispositivo`**:
   - Convi√©rtela en `abstract class`
   - A√±ade un m√©todo abstracto: `abstract void conectar();`

2. **Actualiza `EnchufeInteligente`**:
   - Implementa el m√©todo `conectar()` que imprima: `"Enchufe [nombre] conectado al hub"`

3. **Crea una nueva clase `Termostato`** que herede de `Dispositivo`:
   - Atributo adicional privado:
     - `double temperaturaObjetivo`
   - Constructor que reciba nombre, ubicaci√≥n y temperatura objetivo
   - Implementa `conectar()` que imprima: `"Termostato [nombre] calibrando sensores..."`
   - M√©todo adicional:
     - `void setTemperaturaObjetivo(double temp)`

### Diagrama de Clases

```mermaid
classDiagram
    class Dispositivo {
        <<abstract>>
        -String nombre
        -String ubicacion
        -boolean encendido
        +Dispositivo(nombre, ubicacion)
        +conectar()* void
        +encender()
        +apagar()
    }
    
    class EnchufeInteligente {
        -double consumoWatts
        +conectar() void
    }
    
    class Termostato {
        -double temperaturaObjetivo
        +conectar() void
        +setTemperaturaObjetivo(temp)
    }
    
    Dispositivo <|-- EnchufeInteligente
    Dispositivo <|-- Termostato
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio2 {
    public static void main(String[] args) {
        Dispositivo[] dispositivos = {
            new EnchufeInteligente("Enchufe Nevera", "Cocina", 200.0),
            new Termostato("Termo Sal√≥n", "Sal√≥n", 22.0)
        };
        
        for (Dispositivo d : dispositivos) {
            d.conectar();
        }
    }
}
```

**Salida esperada:**
```
Enchufe Enchufe Nevera conectado al hub
Termostato Termo Sal√≥n calibrando sensores...
```

??? warning "Importante: Clases Abstractas"
    Una vez que `Dispositivo` es `abstract`, **no puedes hacer** `new Dispositivo(...)`.
    Solo puedes instanciar las clases concretas (`EnchufeInteligente`, `Termostato`).

---

## Ejercicio 3: Datos Puros con Records üìä

### Contexto
Los sensores generan lecturas constantemente. Estas lecturas son datos inmutables que no cambian una vez creados. Adem√°s, la configuraci√≥n WiFi de los dispositivos tampoco deber√≠a modificarse una vez establecida.

### üß† Teor√≠a: Introducci√≥n a Records
Desde Java 14 (preview) y 16 (oficial), tenemos una forma concisa de definir "portadores de datos inmutables": los **Records**.

**El Problema:**
Hasta ahora, para crear una clase simple que solo almacene datos (como unas coordenadas `x, y`), ten√≠as que escribir mucho c√≥digo repetitivo (*boilerplate*): constructor, getters, `toString`, `equals` y `hashCode`.

**La Soluci√≥n:**
Un `record` simplifica esto dr√°sticamente. Al definir un record, el compilador genera autom√°ticamente:
- Constructor can√≥nico (con todos los argumentos).
- M√©todos de acceso (con el mismo nombre que el campo, ej: `valor()` en vez de `getValor()`).
- `equals()` y `hashCode()` basados en el contenido.
- `toString()` con formato √∫til.
- La clase y sus campos son `final` (inmutables).

**Comparativa:**

```java
// CLASE TRADICIONAL (Verborrea)
public class Punto {
    private final int x;
    private final int y;
    
    public Punto(int x, int y) { 
        this.x = x; 
        this.y = y; 
    }
    
    // Y faltan getters, toString, equals, hashCode...
}

// RECORD (Conciso y limpio)
public record Punto(int x, int y) {} 
```

### Objetivo

Distinguir entre entidades con identidad (clases) y valores puros (records).

### Enunciado

1. **Crea un `record ConfiguracionWifi`**:
   - Componentes: `String ssid`, `String password`

2. **Crea un `record Temperatura`**:
   - Componentes: `double valor`, `String unidad` (ej: "C" o "F")

3. **Modifica la clase `Termostato`**:
   - A√±ade un atributo privado: `ConfiguracionWifi wifi`
   - Modifica el constructor para recibir tambi√©n la configuraci√≥n WiFi
   - A√±ade un m√©todo: `Temperatura leerTemperatura()` que devuelva una temperatura aleatoria entre 18 y 25 grados Celsius

### Diagrama Conceptual

```mermaid
classDiagram
    class Termostato {
        -ConfiguracionWifi wifi
        +leerTemperatura() Temperatura
    }
    
    class ConfiguracionWifi {
        <<record>>
        +String ssid
        +String password
    }
    
    class Temperatura {
        <<record>>
        +double valor
        +String unidad
    }
    
    Termostato --> ConfiguracionWifi : usa
    Termostato ..> Temperatura : crea
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio3 {
    public static void main(String[] args) {
        ConfiguracionWifi wifi = new ConfiguracionWifi("MiCasa_5G", "password123");
        Termostato termo = new Termostato("Termo Dormitorio", "Dormitorio", 21.0, wifi);
        
        termo.conectar();
        
        // Leer temperatura 3 veces
        for (int i = 0; i < 3; i++) {
            Temperatura temp = termo.leerTemperatura();
            System.out.println("Lectura " + (i+1) + ": " + temp.valor() + "¬∞" + temp.unidad());
        }
        
        // Intentar modificar el record (esto NO compilar√° si lo descomentas)
        // temp.valor = 30.0; // ERROR: los records son inmutables
    }
}
```

**Salida esperada (valores aleatorios):**
```
Termostato Termo Dormitorio calibrando sensores...
Lectura 1: 22.3¬∞C
Lectura 2: 19.8¬∞C
Lectura 3: 23.1¬∞C
```

??? tip "Pista: Generar temperatura aleatoria"
    Usa `Math.random()` para generar un n√∫mero entre 0 y 1, luego esc√°lalo:
    ```java
    double temp = 18 + (Math.random() * 7); // Entre 18 y 25
    return new Temperatura(temp, "C");
    ```

??? info "¬øPor qu√© usar Records?"
    - **`ConfiguracionWifi`**: Es un valor inmutable. Una vez configurado el WiFi, no cambia.
    - **`Temperatura`**: Es una lectura puntual. No tiene sentido "modificar" una lectura pasada.
    - **`Termostato`**: Es una entidad con identidad. Tiene estado que cambia (encendido/apagado, temperatura objetivo).

---

## Ejercicio 4: Seguridad con `final` üîí

### Contexto
Algunos dispositivos son cr√≠ticos para la seguridad del hogar. Una cerradura inteligente no debe permitir que otros programadores creen subclases que modifiquen su comportamiento de seguridad.

### Objetivo
Usar el modificador `final` para cerrar una jerarqu√≠a y entender sus implicaciones de dise√±o.

### Enunciado

1. **Crea una clase `CerraduraInteligente`** que herede de `Dispositivo`:
   - Marca la clase como `final`
   - Atributo privado: `boolean bloqueada`
   - Constructor que reciba nombre y ubicaci√≥n (por defecto, bloqueada = true)
   - Implementa `conectar()` que imprima: `"Cerradura [nombre] verificando credenciales..."`
   - M√©todos adicionales:
     - `void bloquear()` - establece bloqueada = true
     - `void desbloquear()` - establece bloqueada = false
     - `String getEstadoSeguridad()` - devuelve "Bloqueada" o "Desbloqueada"

2. **Intenta crear una subclase** de `CerraduraInteligente` (esto debe fallar):
   ```java
   // Esto NO debe compilar
   public class CerraduraHackeada extends CerraduraInteligente {
       // ...
   }
   ```

### Diagrama de Clases

```mermaid
classDiagram
    class Dispositivo {
        <<abstract>>
        +conectar()* void
    }
    
    class CerraduraInteligente {
        <<final>>
        -boolean bloqueada
        +conectar() void
        +bloquear()
        +desbloquear()
        +getEstadoSeguridad() String
    }
    
    Dispositivo <|-- CerraduraInteligente
    
    note for CerraduraInteligente "No se puede heredar de esta clase"
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio4 {
    public static void main(String[] args) {
        CerraduraInteligente cerradura = new CerraduraInteligente("Puerta Principal", "Entrada");
        
        cerradura.conectar();
        System.out.println("Estado: " + cerradura.getEstadoSeguridad());
        
        cerradura.desbloquear();
        System.out.println("Estado tras desbloquear: " + cerradura.getEstadoSeguridad());
        
        cerradura.bloquear();
        System.out.println("Estado tras bloquear: " + cerradura.getEstadoSeguridad());
    }
}
```

**Salida esperada:**
```
Cerradura Puerta Principal verificando credenciales...
Estado: Bloqueada
Estado tras desbloquear: Desbloqueada
Estado tras bloquear: Bloqueada
```

??? warning "¬øPor qu√© `final`?"
    Marcar `CerraduraInteligente` como `final` impide que alguien cree una subclase que:
    
    - Sobrescriba el m√©todo `desbloquear()` para hacerlo inseguro
    - A√±ada puertas traseras al sistema de seguridad
    
    Es una decisi√≥n de **dise√±o**: "Esta l√≥gica es cr√≠tica y est√° completa, no debe modificarse".

---

## üéØ Desaf√≠o Extra (Opcional)

Crea un programa `GestorCasa` que:

1. Cree un array de `Dispositivo[]` con al menos 5 dispositivos diferentes (enchufes, termostatos, cerraduras).
2. Conecte todos los dispositivos usando un bucle.
3. Encienda todos los dispositivos.
4. Muestre un resumen del estado de cada uno.

**Pista**: Usa polimorfismo. Aunque cada dispositivo es de un tipo diferente, todos comparten la interfaz de `Dispositivo`.

---

## üìö Conceptos Clave Aprendidos

- ‚úÖ **Herencia**: Reutilizar c√≥digo mediante `extends` y `super`
- ‚úÖ **Clases Abstractas**: Definir contratos con m√©todos abstractos
- ‚úÖ **Records**: Modelar datos inmutables vs entidades con estado
- ‚úÖ **Final**: Cerrar jerarqu√≠as para seguridad y dise√±o
