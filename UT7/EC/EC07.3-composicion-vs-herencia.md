# EC07.3 - Composici√≥n vs Herencia üß©

**Tem√°tica**: Sistema de Notificaciones de Seguridad

Hasta ahora hemos usado mucho la herencia ("Es un"). Pero cuando los sistemas crecen, la herencia puede volverse r√≠gida y problem√°tica. En esta pr√°ctica descubrir√°s por qu√© se suele decir "Prefiere Composici√≥n sobre Herencia" y c√≥mo dise√±ar sistemas m√°s flexibles.

---

## Ejercicio 1: La Trampa de la Herencia (El Problema) üï∏Ô∏è

### Contexto
Est√°s dise√±ando un sistema de alarmas. Al principio, solo necesitabas enviar correos. Luego SMS. Luego ambos. Y pronto te pedir√°n notificaciones Push. Si intentas solucionar esto solo con herencia, ver√°s que el n√∫mero de clases explota.

### Objetivo
Demostrar la "explosi√≥n combinatoria" de clases al usar herencia para combinar comportamientos.

### Enunciado

1. **Crea una clase abstracta `Notificador`** con:
   - M√©todo abstracto `void enviar(String mensaje)`.

2. **Crea subclases concretas**:
   - `NotificadorEmail`: Imprime "Enviando EMAIL: [mensaje]".
   - `NotificadorSMS`: Imprime "Enviando SMS: [mensaje]".

3. **El Problema**: Ahora el jefe quiere un notificador que env√≠e **a la vez** por Email y SMS.
   - Crea la clase `NotificadorEmailYSMS` que herede de `Notificador` e implemente ambos comportamientos (tendr√°s que repetir c√≥digo o hacer malabares).
   - **Reflexiona**: ¬øQu√© pasar√≠a si a√±adimos "WhatsApp"? Tendr√≠as que crear `NotificadorEmailYWhatsApp`, `NotificadorSMSYWhatsApp`, `NotificadorEmailYSMSYWhatsApp`... ¬°Es insostenible!

### Diagrama de Clases (Problem√°tico)

```mermaid
classDiagram
    class Notificador { <<abstract>> +enviar() }
    class NotificadorEmail
    class NotificadorSMS
    class NotificadorEmailYSMS
    
    Notificador <|-- NotificadorEmail
    Notificador <|-- NotificadorSMS
    Notificador <|-- NotificadorEmailYSMS : ‚ö†Ô∏è Explosi√≥n de clases
```

---

## Ejercicio 2: La Soluci√≥n con Composici√≥n (Flexibilidad) üß±

### Contexto
En lugar de ser un tipo fijo de notificador, vamos a hacer que nuestro gestor *tenga* un canal de env√≠o. As√≠ podemos cambiar el canal en caliente sin crear nuevas clases raras.

### Objetivo
Usar el patr√≥n **Composici√≥n** (y Strategy simplificado) para desacoplar el "Gestor" del "Mecanismo de env√≠o".

### Enunciado

1. **Define la interfaz `CanalEnvio`**:
   - M√©todo: `void enviar(String mensaje)`.

2. **Crea implementaciones del canal**:
   - `CanalEmail`: Imprime "EMAIL: ...".
   - `CanalSMS`: Imprime "SMS: ...".

3. **Crea la clase `GestorNotificaciones`**:
   - Atributo privado: `CanalEnvio canal` (¬°Composici√≥n: TIENE UN canal!).
   - Constructor: Recibe el canal inicial.
   - M√©todo `void notificar(String mensaje)`: Delega el env√≠o al canal (`canal.enviar(mensaje)`).
   - M√©todo `void setCanal(CanalEnvio nuevoCanal)`: Permite cambiar el canal din√°micamente.

### Diagrama de Clases (Soluci√≥n)

```mermaid
classDiagram
    class GestorNotificaciones {
        -CanalEnvio canal
        +notificar(msg)
        +setCanal(CanalEnvio)
    }
    class CanalEnvio { <<interface>> +enviar() }
    class CanalEmail
    class CanalSMS
    
    GestorNotificaciones o-- CanalEnvio : TIENE UN (Composici√≥n)
    CanalEnvio <|.. CanalEmail
    CanalEnvio <|.. CanalSMS
```

### Prueba tu c√≥digo

```java
public class PruebaComposicion {
    public static void main(String[] args) {
        // Empezamos usando Email
        GestorNotificaciones gestor = new GestorNotificaciones(new CanalEmail());
        gestor.notificar("Alerta de intrusi√≥n 1");
        
        // ¬°Cambiamos a SMS en tiempo de ejecuci√≥n!
        System.out.println("--- Cambiando a canal de emergencia ---");
        gestor.setCanal(new CanalSMS());
        gestor.notificar("Alerta de intrusi√≥n 2");
    }
}
```

---

## Ejercicio 3: Composici√≥n M√∫ltiple (Arrays) üì¢

### Contexto
¬øY si queremos enviar por Email Y por SMS? Con herencia era un pesadilla (`NotificadorEmailYSMS`). Con composici√≥n es trivial: simplemente nuestro gestor puede *tener* **varios** canales, no solo uno.

### Objetivo
Utilizar arrays para componer un objeto con m√∫ltiples dependencias.

### Enunciado

1. **Crea la clase `NotificadorMultiCanal`**:
   - Atributo: `CanalEnvio[] canales` (Array de interfaces).
   - Constructor: Recibe el array de canales ya creados.
   - M√©todo `void notificarTodos(String mensaje)`: Recorre el array y env√≠a el mensaje por cada uno de los canales configurados.

2. **Prueba**:
   - Crea un array con `new CanalEmail()` y `new CanalSMS()`.
   - Instancia el notificador pas√°ndole ese array.
   - Llama a `notificarTodos`. ¬°Ver√°s que salen ambos mensajes sin haber creado ninguna clase "Mixta"!

```java
CanalEnvio[] misCanales = { new CanalEmail(), new CanalSMS() };
NotificadorMultiCanal multi = new NotificadorMultiCanal(misCanales);
multi.notificarTodos("¬°Fuego en la cocina!");
```

---

## Ejercicio 4: Desaf√≠o de Dise√±o - Sistema de Seguridad üìπ

### Contexto
Un "Sistema de Seguridad" suele tener c√°maras y sensores. Un error com√∫n de novato es pensar: "El sistema *es* como una c√°mara grande", y heredar de `Camara`. ¬°Error! Un sistema *TIENE* c√°maras.

### Enunciado

1. **Clases Componentes**:
   - `Camara` con m√©todo `grabar()`.
   - `SensorMovimiento` con m√©todo `detectar()`.

2. **Clase `SistemaSeguridad`**:
   - No debe heredar de nada.
   - Debe tener (composici√≥n) una `Camara` y un `SensorMovimiento` como atributos.
   - Constructor que inicialice ambos componentes.
   - M√©todo `void activarProtocolo()`: Debe llamar a `detectar()` del sensor y luego a `grabar()` de la c√°mara.

### Reflexi√≥n Final
Al usar composici√≥n:
- Puedes cambiar la c√°mara por una `CamaraTermica` (si usas interfaces o herencia en la c√°mara) sin tocar el `SistemaSeguridad`.
- El `SistemaSeguridad` no se contamina con m√©todos de la c√°mara (no heredas cosas que no necesitas).

---

## üìö Conceptos Clave Reforzados

- ‚úÖ **Herencia (IS-A)**: √ötil para jerarqu√≠as reales, pero r√≠gida para combinar comportamientos.
- ‚úÖ **Composici√≥n (HAS-A)**: M√°s flexible. Permite cambiar partes del c√≥digo en tiempo de ejecuci√≥n.
- ‚úÖ **Inyecci√≥n de Dependencias**: Pasar los objetos que necesitamos (los canales) en lugar de crearlos dentro.
- ‚úÖ **Delegaci√≥n**: El `Gestor` no env√≠a el mensaje √©l mismo, se lo *delega* al objeto `canal`.
