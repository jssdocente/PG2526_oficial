# EC07.0 - Fundamentos de Object: Identidad VS Igualdad

## üéØ Objetivos
El objetivo de este ejercicio es comprender la diferencia fundamental entre la **identidad** de un objeto (su direcci√≥n de memoria) y su **igualdad l√≥gica** (su contenido), as√≠ como la importancia de una correcta representaci√≥n textual de los objetos.

---

## üìö Contexto

En Java, **todas las clases** heredan impl√≠citamente de la clase madre `Object`. Esto significa que cualquier objeto que crees tiene heredados ciertos m√©todos, entre ellos:
1. `toString()`: Devuelve una representaci√≥n en texto del objeto.
2. `equals(Object obj)`: Decide si dos objetos son "iguales".
3. `hashCode()`: Devuelve un n√∫mero identificador para el objeto.

```mermaid
classDiagram
    class Object {
        +toString() String
        +equals(Object obj) boolean
        +hashCode() int
        +...()
    }
    class Libro {
        -String isbn
        -String titulo
        -String autor
        +toString() String
        +equals(Object obj) boolean
        +hashCode() int
    }
    Object <|-- Libro : hereda impl√≠citamente de
```

El problema es que la implementaci√≥n por defecto de estos m√©todos (la que viene en `Object`) suele ser insuficiente para nuestros programas.

---

## üõ†Ô∏è Ejercicio: La Biblioteca Secreta

Vamos a modelar una clase `Libro` muy simple.

### Parte 1: El problema de la presentaci√≥n (`toString`)

Crea la clase `Libro` con los siguientes atributos:
- `isbn` (String): El identificador √∫nico del libro.
- `titulo` (String).
- `autor` (String).

```java
public class Libro {
    private String isbn;
    private String titulo;
    private String autor;

    public Libro(String isbn, String titulo, String autor) {
        this.isbn = isbn;
        this.titulo = titulo;
        this.autor = autor;
    }
    
    // ... getters y setters ...
}
```

Ahora, crea una clase `TestObject` con un `main`:

```java
Libro l1 = new Libro("123-A", "Java para Novatos", "Pepe Perez");
System.out.println(l1);
```

**Observa:**
Ver√°s algo como `Libro@7ad041f3`. Esto es el nombre de la clase + su c√≥digo hash en hexadecimal. **No nos sirve**.

üëâ **Tarea 1:**
Sobrescribe el m√©todo `toString` en `Libro` para que al imprimir salga algo legible, por ejemplo: `"[123-A] Java para Novatos - Pepe Perez"`.

---

## üëØ Parte 2: El dilema de los gemelos (`==` VS `equals`)

A√±ade lo siguiente a tu `main`:

```java
Libro l1 = new Libro("123-A", "Java para Novatos", "Pepe Perez");
Libro l2 = new Libro("123-A", "Java para Novatos", "Pepe Perez");

if (l1 == l2) {
    System.out.println("Son el mismo objeto (referencia)");
} else {
    System.out.println("Son diferentes objetos (referencia)");
}

if (l1.equals(l2)) {
    System.out.println("Son iguales (contenido)");
} else {
    System.out.println("Son diferentes (contenido)");
}
```

**An√°lisis:**
- ¬øPor qu√© dice que son diferentes referencias? Porque `new` siempre crea un hueco nuevo en memoria. Son dos objetos f√≠sicos distintos ("dos libros id√©nticos en la mesa").
- ¬øPor qu√© `equals` dice que son diferentes? Porque por defecto, `Object.equals(o)` hace lo mismo que `==`. Compara direcciones de memoria.

üëâ **Tarea 2:**
Sobrescribe el m√©todo `equals` en la clase `Libro`. Dos libros deben considerarse iguales **si tienen el mismo ISBN**, independientemente del t√≠tulo o autor (asumimos que el ISBN es √∫nico).

**Gu√≠a de implementaci√≥n segura de `equals`:**
1. Comprobar si `this == obj` (¬øes el mismo objeto f√≠sico? -> true).
2. Comprobar si `obj == null` (¬øes nulo? -> false).
3. Comprobar clases: `getClass() != obj.getClass()` (¬øes otro tipo de objeto? -> false).
4. Hacer **Casting**: Convertir `obj` a `Libro`.
5. Comparar el campo clave: `isbn.equals(otroLibro.isbn)`.

---

## ü§ù Parte 3: El contrato sagrado (`hashCode`)

### üß† ¬øQu√© es un Hash y el HashCode?

Antes de implementarlo, entendamos el concepto:

*   **Hash (resumen)**: Es como una **huella digital** simplificada de un archivo o dato. Imagina que reduces todo el texto de *El Quijote* a un solo n√∫mero. Si cambias una sola letra del libro, ese n√∫mero deber√≠a cambiar totalmente.
*   **HashCode (en Java)**: Es un n√∫mero entero (`int`) que representa al objeto. Java usa este n√∫mero para "organizar" los objetos en memoria r√°pidamente (como en cajones etiquetados por n√∫mero).

**La regla de oro inquebrantable:**

> **"Si dos objetos son iguales seg√∫n `.equals()`, ENTONCES deben tener el mismo `.hashCode()`"**

Aunque ahora mismo no estemos usando colecciones que dependan del hash (como `HashSet` o `HashMap`), **romper esta regla es peligroso**. Si no sobrescribimos `hashCode`, dos libros con el mismo ISBN tendr√°n c√≥digos hash diferentes (basados en su memoria), violando el contrato.

üëâ **Tarea 3:**

Sobrescribe `hashCode` para que sea consistente.
*Pista:* Como la igualdad depende solo del ISBN, el hashcode tambi√©n deber√≠a generarse solo a partir del ISBN.

```java
@Override
public int hashCode() {
    return Objects.hash(isbn); 
    // O si no quieres usar Objects: return this.isbn.hashCode();
}
```

---

## üß™ Comprobaci√≥n Final

Ampl√≠a tu `main` para verificar que ahora `l1.equals(l2)` devuelve `true` y que `l1.hashCode() == l2.hashCode()` tambi√©n es `true`.
