# EC07.2 - Interfaces y Polimorfismo Avanzado

**Tem√°tica**: Sistema de Casa Inteligente (Evoluci√≥n)

En esta segunda parte, expandiremos nuestro sistema dom√≥tico para que sea m√°s flexible. Ya no dependeremos solo de la herencia jer√°rquica (qu√© *es* un dispositivo), sino de sus capacidades (qu√© *puede hacer*), utilizando interfaces y polimorfismo avanzado.

---

## Ejercicio 1: Definiendo Habilidades (Interfaces B√°sicas) üéõÔ∏è

### Contexto
Queremos controlar cualquier cosa, no necesariamente un "Dispositivo" de nuestra marca. Una simple bombilla o una tele antigua podr√≠an ser controlables si les ponemos un adaptador. Necesitamos un "contrato" universal de control.

### Objetivo
Definir un comportamiento com√∫n mediante una `interface` y desacoplar la implementaci√≥n de la jerarqu√≠a de clases.

### Enunciado

1. **Crea la interfaz `Controlable`**:
   - M√©todos abstractos:
     - `void encender()`
     - `void apagar()`
     - `boolean estaEncendido()`

2. **Crea las clases `Lampara` y `Televisor`**:
   - Ambas deben implementar `Controlable`.
   - Deben tener un atributo privado `boolean encendido`.
   - Implementa los m√©todos para cambiar y consultar el estado, mostrando un mensaje por consola (ej: "L√°mpara encendida").

### Diagrama de Clases

```mermaid
classDiagram
    class Controlable {
        <<interface>>
        +encender()
        +apagar()
        +estaEncendido() boolean
    }
    
    class Lampara {
        -boolean encendido
    }
    
    class Televisor {
        -boolean encendido
    }
    
    Controlable <|.. Lampara
    Controlable <|.. Televisor
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio1 {
    public static void main(String[] args) {
        // Polimorfismo puro con interfaces
        Controlable[] misCosas = {
            new Lampara(),
            new Televisor()
        };
        
        for (Controlable c : misCosas) {
            c.encender();
            System.out.println("¬øEst√° encendido? " + c.estaEncendido());
            c.apagar();
        }
    }
}
```

---

## Ejercicio 2: M√∫ltiples Habilidades y Default Methods ü§ñ

### Contexto
Un Robot Aspirador es complejo: se mueve, limpia, se conecta al WiFi y se puede programar. Adem√°s, queremos que todos los dispositivos conectables tengan una forma est√°ndar de probar su conexi√≥n sin obligar a reescribir c√≥digo siempre.

### Objetivo
Practicar la herencia m√∫ltiple de interfaces y el uso de m√©todos `default`.

### Enunciado

1. **Crea la interfaz `Conectable`**:
   - M√©todo abstracto: `void conectarWifi(String red)`
   - M√©todo **`default`**: `void testConexion()` que imprima "Realizando test de conexi√≥n est√°ndar... OK".

2. **Crea la interfaz `Programable`**:
   - M√©todo abstracto: `void programar(int horas)`

3. **Crea la clase `RobotAspirador`**:
   - Debe implementar **tres interfaces**: `Controlable`, `Conectable` y `Programable`.
   - Implementa todos los m√©todos requeridos con mensajes descriptivos.
   - **Nota**: No es necesario que herede de `Dispositivo` (del EC07.1) para este ejercicio, puede ser una clase independiente.

### Diagrama de Clases

```mermaid
classDiagram
    class Controlable { <<interface>> }
    class Conectable { 
        <<interface>> 
        +conectarWifi(red)
        +testConexion()
    }
    class Programable { 
        <<interface>> 
        +programar(horas)
    }
    
    class RobotAspirador {
        +limpiar()
    }
    
    Controlable <|.. RobotAspirador
    Conectable <|.. RobotAspirador
    Programable <|.. RobotAspirador
```

### Prueba tu c√≥digo

```java
public class PruebaEjercicio2 {
    public static void main(String[] args) {
        RobotAspirador robot = new RobotAspirador();
        
        // Probamos todas sus facetas
        robot.conectarWifi("MiCasa_5G");
        robot.testConexion(); // M√©todo default
        
        robot.programar(12);
        robot.encender();
    }
}
```

---

## Ejercicio 3: Polimorfismo Flexible y Pattern Matching üîç

### Contexto
En una casa real, tenemos una caja llena de cachivaches mezclados. Necesitamos un sistema que sepa identificar qu√© es cada cosa y usarlo seg√∫n sus capacidades, sin que explote el programa.

### Objetivo
Manejar colecciones heterog√©neas (`Object[]`) y usar `instanceof` con Pattern Matching (Java 16+) para descubrir capacidades din√°micamente.

### Enunciado

1. Crea una clase `PruebaEjercicio3` con un `main`.
2. Define un **array de Objects** (`Object[]`) con 5 posiciones.
3. Ll√©nalo con una mezcla de objetos: `Lampara`, `Televisor`, `RobotAspirador` y quiz√°s un `String` ("Soy un intruso").
4. Recorre el array con un bucle:
   - Si el objeto es `Controlable`, enci√©ndelo.
   - Si es `Programable`, progr√°malo para dentro de 2 horas.
   - **Espec√≠ficamente**, si es un `RobotAspirador` (que tiene m√©todos propios no de interfaz, inventa un m√©todo `limpiar()` si no lo hiciste antes), haz que limpie.
   - Si no es nada de lo anterior, imprime "Objeto desconocido".

**Requisito**: Usa la sintaxis moderna de `instanceof` (Pattern Matching).

```java
// Ejemplo de sintaxis antigua (EVITAR)
if (obj instanceof Lampara) {
    Lampara l = (Lampara) obj;
    // ...
}

// Ejemplo Moderno (USAR)
if (obj instanceof Lampara l) {
    l.encender();
}
```

---

## Ejercicio 4: Desacoplamiento (Depender de Abstracciones) üéÆ

### Contexto
Queremos fabricar un mando a distancia universal. Si fabricamos un mando que solo funcione con `Televisor`, tendremos que fabricar otro para `Lampara`. Eso es caro e ineficiente.

### Objetivo
Aplicar el principio de Inversi√≥n de Dependencia: depender de `Controlable`, no de clases concretas.

### Enunciado

1. **Crea la clase `MandoUniversal`**:
   - Atributo privado: `Controlable dispositivo` (¬°F√≠jate que es la interfaz!).
   - Constructor: Recibe un objeto `Controlable` y lo asigna.
   - M√©todo `void botonRojo()`: Si el dispositivo est√° encendido, lo apaga. Si est√° apagado, lo enciende.

2. **Prueba en el main**:
   - Crea una `Lampara` y un `Televisor`.
   - Crea un `MandoUniversal` asociado a la l√°mpara y pulsa el bot√≥n rojo.
   - Crea otro `MandoUniversal` asociado al televisor y pulsa el bot√≥n rojo.

### Diagrama Conceptual

```mermaid
classDiagram
    class MandoUniversal {
        -Controlable dispositivo
        +MandoUniversal(Controlable d)
        +botonRojo()
    }
    
    class Controlable { <<interface>> }
    
    MandoUniversal --> Controlable : usa
```

> **Reflexi√≥n**: ¬øTu `MandoUniversal` necesita saber c√≥mo funciona internamente la `Lampara`? No. Solo necesita saber que *es controlable*. Eso es desacoplamiento.

---

## Ejercicio 5: Modernizando con Switch Pattern Matching üîÄ

### Contexto
El operador `instanceof` es √∫til, pero cuando tenemos muchas condiciones encadenadas (`if... else if... else if`), el c√≥digo se vuelve dif√≠cil de leer. Desde Java 17 (preview) y 21 (est√°ndar), podemos usar `switch` directamente con tipos.

### Objetivo
Utilizar **Switch Expressions** con **Pattern Matching** para simplificar la l√≥gica de control basada en tipos.

### Enunciado

1. **Crea una clase `UtilidadesDomoticas`**:
   - Define un m√©todo est√°tico: `public static String obtenerDetalle(Object objeto)`.
   - Implementa la l√≥gica usando una expresi√≥n `switch (objeto)` para devolver un String diferente seg√∫n el tipo:
     - Si es `Lampara`: "Es una l√°mpara [Encendida/Apagada]".
     - Si es `RobotAspirador`: "Es un robot aspirador inteligente".
     - Si es `Televisor`: "Es un televisor".
     - Si es `String`: "Es solo texto: [valor del texto]".
     - Si es `null`: "¬°Cuidado! Objeto nulo detectado".
     - `default`: "Objeto desconocido de tipo [Nombre de la clase]".

2. **Prueba tu c√≥digo**:
   - En el `main` de una nueva clase de prueba, llama a `obtenerDetalle` pasando diferentes objetos (incluyendo un `null`).

### C√≥digo de Ejemplo (Java 21)

```java
// As√≠ se ve un Switch con Pattern Matching
return switch (objeto) {
    case Lampara l -> "L√°mpara (Encendida: " + l.estaEncendido() + ")";
    case RobotAspirador r -> "Robot Aspirador listo";
    case String s -> "Texto: " + s;
    case null -> "Objeto nulo";
    default -> "Tipo desconocido: " + objeto.getClass().getSimpleName();
};
```

> **Nota**: Si tu versi√≥n de Java es anterior a la 21, es posible que necesites activar "preview features" o que esta sintaxis no compile. Aseg√∫rate de estar usando Java 21+.

---

## üìö Conceptos Clave Reforzados

- ‚úÖ **Interfaces**: Definir contratos de comportamiento.
- ‚úÖ **Herencia M√∫ltiple de Tipos**: Una clase puede ser muchas cosas a la vez (`Controlable`, `Conectable`...).
- ‚úÖ **Default Methods**: A√±adir funcionalidad a interfaces sin romper implementaciones existentes.
- ‚úÖ **instanceof (Pattern Matching)**: Inspeccionar tipos en tiempo de ejecuci√≥n de forma segura y concisa.
- ‚úÖ **Desacoplamiento**: Escribir c√≥digo que dependa de interfaces permite cambiar las piezas ("Clases") sin cambiar el sistema ("MandoUniversal").
