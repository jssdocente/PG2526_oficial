# ‚òï B07.1 La Cafetera Inteligente (Ampliaci√≥n interfaces)

## üìÑ Enunciado

La cadena de cafeter√≠as **Starbucks** üåü est√° actualizando su software. Necesita una aplicaci√≥n robusta que gestione no solo el estado individual de sus cafeteras, sino tambi√©n flotas completas de m√°quinas utilizando est√°ndares modernos de Java (Interfaces).

### Parte 1: La Cafetera (L√≥gica y Estado)

Tu misi√≥n es crear la clase `Cafetera` que controle el estado de cada m√°quina.
- üÜî **id**: N√∫mero correlativo asignado al fabricarse.
- üìè **tama√±o**: Capacidad m√°xima en ml.
- üíß **cantidadActual**: Cantidad de caf√© disponible.

> **‚ö†Ô∏è Restricciones**:
> - **Tama√±o M√≠nimo**: 300 ml.
> - **Tama√±o M√°ximo**: 3000 ml.
> - Constantes: `MINIMO`, `MAXIMO`.

#### 1.1 Constructores
1.  **Defecto**: Tama√±o 1000ml, Vac√≠a.
2.  **Por Tama√±o**: Se ajusta a los l√≠mites (300-3000). Empieza **llena**.
3.  **Por Tama√±o y Cantidad**: Se ajusta al m√°ximo si la cantidad excede. Aplica l√≠mites de tama√±o.

#### 1.2 M√©todos de Utilidad
- üö∞ **`llenarCafetera()`**: Llena al m√°ximo.
- ‚òï **`servirTaza(TipoTaza)`**: Resta capacidad. Tipos: `SHORT`(200), `TALL`(300), `GRANDE`(450), `VENTI`(675), `TRENTA`(900). **Regla**: Si queda <200ml, se vac√≠a autom√°ticamente.
- üóëÔ∏è **`vaciarCafetera()`**: Cantidad a 0. Contabiliza desperdicio.
- ‚ûï **`agregarCafe(int)`**: A√±ade sin pasar el m√°ximo.
- üñ®Ô∏è **`imprimir()`**: Formato `[ Cafetera: id | Capacidad: ... | Cafe: ... ]`.

#### 1.3 M√©todos Est√°ticos
- üìä **`getNumCafeterasCreadas()`**: Total de instancias creadas.
- üöÆ **`getCafeDesperdiciado()`**: Total de caf√© tirado (al vaciar o limpiar).
- üÜö **`masLlena(Cafetera c1, Cafetera c2)`**: Devuelve la que tiene m√°s caf√©.

---

### Parte 2: Interfaces y Colecciones (NUEVO)

Para gestionar la flota de manera profesional, la clase `Cafetera` debe implementar:

#### 2.1 Ordenaci√≥n Natural (`Comparable`)
Implementa `Comparable<Cafetera>`.
- **Criterio**: Ordenar por `cantidadActual`.
- Una cafetera con menos caf√© va antes que una con m√°s.

#### 2.2 Clonaci√≥n (`Cloneable`)
Implementa `Cloneable`.
- Sobrescribe `clone()` para permitir copias exactas de una m√°quina (mismo ID, capacidad y l√≠quido).

#### 2.3 Inventario (`Iterable`)
Crea una nueva clase `InventarioCafeteras` que gestione un conjunto de m√°quinas.
- **Estructura**: `ArrayList<Cafetera>`.
- **Funcionalidad**:
    - `a√±adirCafetera(Cafetera c)`: Agrega al inventario.
    - `ordenarCafeteras()`: Ordena la lista interna (usando el `compareTo` definido).
    - **`iterator()`**: Implementa `Iterable<Cafetera>` para permitir recorrer el inventario con un `foreach`.

---

## üíª 3. Programa Principal

El `Main` debe probar **toda** la funcionalidad (b√°sica + interfaces). Debes obtener una salida similar a esta:

```java
import java.util.Arrays;

public class Principal {
    public static void main(String[] args) {
        // ============================================
        //   PARTE 1: PRUEBAS B√ÅSICAS (L√≥gica POO)
        // ============================================

        // --- üèóÔ∏è CONSTRUCTORES ---
        System.out.println("* Prueba de constructores");
        Cafetera c1 = new Cafetera();         // Defecto
        c1.imprimir();
        Cafetera c2 = new Cafetera(4000);     // Se ajusta a 3000
        c2.imprimir();
        Cafetera c3 = new Cafetera(100);      // Se ajusta a 300
        c3.imprimir();
        Cafetera c4 = new Cafetera(2000);     // Correcto
        c4.imprimir();
        Cafetera c5 = new Cafetera(1500, 0);  // Vac√≠a
        c5.imprimir();
        Cafetera c6 = new Cafetera(800, 500); // 500ml iniciales
        c6.imprimir();
        System.out.println();

        // --- üö∞ LLENAR Y VACIAR ---
        System.out.println("* Prueba llenar/vaciar");
        c5.llenarCafetera();
        c5.imprimir();
        c5.vaciarCafetera(); // Desperdicia 1500
        c5.imprimir();
        System.out.println();

        // --- ‚òï SERVIR Y VACIADO AUTO ---
        System.out.println("* Prueba servir y auto-vaciado");
        c2.imprimir(); // 3000
        c2.servirTaza(TipoTaza.TRENTA); // -900
        c2.servirTaza(TipoTaza.VENTI);  // -675
        c2.imprimir();
        
        System.out.println("* Auto-vaciado (<200ml)");
        // c6 tiene 500. Servimos GRANDE (450). Quedan 50 -> Se vac√≠a.
        c6.servirTaza(TipoTaza.GRANDE); 
        c6.imprimir(); // Debe estar vac√≠a (0)
        System.out.println();

        // --- üìä ESTAD√çSTICAS ---
        System.out.println("- Total Cafeteras: " + Cafetera.getNumCafeterasCreadas());
        System.out.println("- Desperdicio Total: " + Cafetera.getCafeDesperdiciado() + "ml");
        
        // ============================================
        //   PARTE 2: PRUEBAS AVANZADAS (Interfaces)
        // ============================================
        System.out.println("\n#################################");
        System.out.println("   PRUEBAS AVANZADAS INTERFACES");
        System.out.println("#################################");

        // --- üëØ CLONEABLE ---
        System.out.println("\n* Prueba Clonaci√≥n");
        try {
            Cafetera clonC4 = (Cafetera) c4.clone();
            System.out.print("Original: "); c4.imprimir();
            System.out.print("Clon:     "); clonC4.imprimir();
            System.out.println("¬øSon el mismo objeto? " + (c4 == clonC4)); // False
            
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        // --- üìã INVENTARIO ITERABLE ---
        System.out.println("\n* Prueba Inventario (Iterable)");
        InventarioCafeteras flota = new InventarioCafeteras();
        flota.a√±adirCafetera(c1); // 0
        flota.a√±adirCafetera(c2); // ~1425
        flota.a√±adirCafetera(c3); // 300
        flota.a√±adirCafetera(c4); // 2000
        
        // Foreach gracias a Iterable
        for (Cafetera c : flota) {
            System.out.print("-> "); c.imprimir();
        }

        // --- ÔøΩ COMPARABLE (ORDENAR) ---
        System.out.println("\n* Prueba Ordenaci√≥n (por cantidad)");
        flota.ordenarCafeteras();
        for (Cafetera c : flota) {
            System.out.print("-> "); c.imprimir();
        }
        // El orden deber√≠a ser ascendente seg√∫n la cantidad de caf√© restante.
    }
}
```

---

## ‚úÖ Criterios de Calificaci√≥n

| Concepto | Puntos |
| :--- | :---: |
| **L√≥gica B√°sica** (Atributos, Constructores, M√©todos) | **3.0** |
| **Estad√≠sticas** (Acumuladores Est√°ticos) | **1.0** |
| **Interfaz Comparable** (Ordenaci√≥n) | **1.5** |
| **Interfaz Cloneable** | **1.5** |
| **Clase Inventario** (Iterable + ArrayList) | **1.5** |
| **Main Completo** (Pruebas de todo) | **1.5** |

### ‚õî Penalizaciones
- **No compila**: -10 ptos.
- **Nomenclatura incorrecta**: -1 pto.
- **Mal uso de Interfaces**: Implementar l√≥gica de ordenaci√≥n manualmente en lugar de usar `Collections.sort` y `Comparable`: -2 ptos.
