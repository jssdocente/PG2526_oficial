# ‚öì B06.2 Hundir la Flota: Edici√≥n Orientada a Objetos

En la unidad anterior, programaste el juego "Hundir la Flota" utilizando matrices (`int[][]`) y un mont√≥n de m√©todos est√°ticos. ¬°Funcionaba! Pero seamos sinceros: pasar `x` e `y` por todos lados y recordar que `6` significa "tocado" es agotador y propenso a errores.

En este reto, vamos a **redise√±ar** el juego completo aplicando POO. Vamos a modelar los conceptos del juego (Barcos, Tableros, Jugadores) como **Objetos**.

> üìÇ **Recursos**: Se proporciona la carpeta `B06.2_base` con la estructura de clases sugerida (`Direccion`, `EstadoCasilla`, `Jugador`, etc.) listas para ser implementadas.

---

## üèóÔ∏è El Nuevo Dise√±o

Olv√≠date de `int[][] tablero` "pelado". Piensa en las entidades que forman parte del juego.

### üìç 1. La Jerarqu√≠a de Coordenadas
El √°tomo del juego. Vamos a hacerlo robusto usando **Herencia**.

- **Clase Abstracta `Componente`**:
    - Representa una parte de la coordenada (fila o columna).
    - Atributo: `int valor` (el √≠ndice num√©rico real).
    - M√©todo: `getValue()` que devuelve ese valor.

- **Clase `Columna` extends `Componente`**:
    - Constructor: `public Columna(String letra)` -> Convierte "A" en 0, "B" en 1, etc.
    - `toString()`: Devuelve la letra ("A").

- **Clase `Fila` extends `Componente`**:
    - Constructor: `public Fila(int numero)`.
    - `toString()`: Devuelve el n√∫mero.

- **Clase `Coordenada`**:
    - Atributos: `Fila fila`, `Columna columna`.
    - **Constructor**: `public Coordenada(String coordenada)` -> Parsea un string como "A5" o "C10".
        - Debe separar la letra de la columna y el n√∫mero de la fila.
        - Crear los objetos `Fila` y `Columna` correspondientes.
        - **IMPORTANTE**: Internamente usamos √≠ndices 0-9 para el array, pero mostrarmos A-J y 1-10.
    - `toString()`: Devuelve "A-5".
    - `equals(Object o)`: Vital para comparar.

### üö¢ 2. La Jerarqu√≠a de Barcos (Herencia y Polimorfismo)
Un barco ya no es un simple conjunto de n√∫meros. Ahora cada tipo de nav√≠o tiene personalidad propia.

- **Clase Abstracta `Barco`**:
    - **Atributos**:
        - `nombre` (String).
        - `tama√±o` (int).
        - `vidas` (int).
        - `cargasHabilidad` (int): N√∫mero de veces que puede usar su habilidad especial.
    - **M√©todos Concretos**:
        - `recibirImpacto()`: Resta una vida.
        - `estaHundido()`: Devuelve `true` si las vidas llegan a 0.
    - **M√©todo Abstracto**:
        - `public abstract void activarHabilidadEspecial(Tablero tableroObjetivo, Coordenada objetivo);`

#### Tipos de Barcos (Subclases)
Debes implementar las siguientes clases concretas. Cada una sobrescribe `activarHabilidadEspecial`:

| Clase | Tama√±o | Cargas | Habilidad Especial | Efecto |
| :--- | :---: | :---: | :--- | :--- |
| **`Portaaviones`** | 5 | 1 | **Reconocimiento A√©reo** | Revela el estado (Agua/Barco) de un √°rea de **3x3** alrededor del objetivo sin da√±ar. |
| **`Buque`** | 4 | 1 | **Ataque en Cruz** | Dispara a **toda la fila y toda la columna** de la coordenada indicada. |
| **`Submarino`** | 3 | 1 | **Inmersi√≥n** | Se vuelve invulnerable a los disparos rivales durante el **siguiente turno**. |
| **`Acorazado`** | 4 | 1 | **Bombardeo en Zona** | Impacta en la coordenada objetivo y en las 4 casillas adyacentes (+). |
| **`Destructor`** | 2 | 2 | **Disparo Doble** | Permite disparar de nuevo en el mismo turno. |

---

### üó∫Ô∏è 3. La Clase `Tablero` e Interfaces
Es el responsable de organizar el juego.

#### Interfaz `Atacable`
Define el contrato para recibir disparos:
```java
public interface Atacable {
    ResultadoDisparo recibirDisparo(Coordenada c);
}
```

#### Clase `Tablero` implements `Atacable`
- **Estructura Interna**:
    - Una matriz de **Casillas**: `private Casilla[][] casillas = new Casilla[10][10];`
    - **Clase `Casilla`** (Clase interna o externa):
        - `EstadoCasilla estado`: Enum (`AGUA`, `AGUA_DISPARADA`, `BARCO`, `TOCADO`).
        - `Barco contenido`: Referencia al objeto Barco (null si no hay).
- **Responsabilidades**:
    - `colocarBarco(Barco b, Coordenada inicio, Direccion d)`: Valida l√≠mites y superposiciones.
    - `recibirDisparo(Coordenada c)`: Gestiona el impacto y actualiza el estado de la casilla y el barco.
    - `mostrar(boolean oculto)`: Imprime el tablero. Si `oculto` es true, no muestra los barcos intactos (vista del rival).

---

### üë§ 4. La Clase `Jugador`
Aqu√≠ gestionamos la inteligencia y el flujo.

- **Clase `Jugador`** (Puede ser abstracta):
    - **Atributos**:
        - `miFlota`: Su propio `Tablero`.
        - `radar`: Referencia al `Tablero` del enemigo (para atacar) o una matriz propia para anotar resultados.
        - `List<Barco> barcos`: Lista polim√≥rfica con todos sus barcos para gestionar las cargas de habilidades.
    - **M√©todo Abstracto**: `Coordenada elegirDisparo()`.

- **`JugadorHumano`**:
    - Pide coordenandas por teclado.
    - Puede elegir: "Disparar normal" o "Usar Habilidad de [Barco]".

- **`JugadorMaquina`**:
    - Dispara aleatoriamente (evitando repetidos).
    - (Opcional) Usa habilidades si tiene cargas disponibles de forma inteligente.

---

## üéÆ El Flujo del Juego (Clase Main)

El bucle principal se beneficia del polimorfismo:

```java
public void jugar() {
    // Inicializaci√≥n...
    while (j1.tieneBarcos() && j2.tieneBarcos()) {
        // Turno J1
        // 1. Elegir acci√≥n (Disparo normal o Habilidad)
        // 2. Ejecutar acci√≥n sobre tablero rival
        // 3. Mostrar resultado
        // 4. Cambio turno
    }
}
```

## üìù Tu Misi√≥n
1.  **Rescata** la l√≥gica de Coordenadas (Fila, Columna).
2.  **Implementa** la Jerarqu√≠a Naval (`Barco` abstracto + 5 tipos) y sus habilidades.
3.  **Gestiona** el Tablero con la matriz de `Casilla` y la interfaz `Atacable`.
4.  **Disfruta** viendo c√≥mo el Polimorfismo maneja las habilidades especiales m√°gicamente.
