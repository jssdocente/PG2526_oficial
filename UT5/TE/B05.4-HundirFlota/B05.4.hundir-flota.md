# ‚öì Proyecto: Hundir la Flota

En este reto, pondr√°s a prueba tus conocimientos sobre **arrays bidimensionales (matrices)**, **l√≥gica de control** y **modularizaci√≥n** implementando el cl√°sico juego de **Hundir la Flota** (Battleship).

## üéØ Objetivo

Completar el c√≥digo base proporcionado en `HundirFlota.java` para que el juego sea plenamente funcional. El juego permite colocar barcos de forma aleatoria en un tablero de 10x10 y jugar contra otro humano o contra la m√°quina.

---

## üèóÔ∏è Estructura de Datos

El juego se basa en dos matrices principales de 10x10: `barcosJ1` y `barcosJ2`. 

Cada casilla de la matriz puede tener uno de los siguientes estados num√©ricos:
*   `0`: **Agua limpia**. No hay nada.
*   `1-5`: **Barco intacto**. El n√∫mero indica el tama√±o del barco (Lancha=1, Crucero=2, Submarino=3, Buque=4, Portaaviones=5).
*   `6`: **Tocado**. Un barco estaba ah√≠ y ha sido alcanzado.
*   `7`: **Agua disparada**. El jugador dispar√≥ aqu√≠ pero no hab√≠a nada.

### ‚öì Tipos de Barco y Resistencia

A diferencia de otros juegos, aqu√≠ el tama√±o del barco define su **resistencia**. 
*   Una **Lancha (1)** ocupa una casilla: con un solo impacto (`6`), queda destruida.
*   Un **Portaaviones (5)** ocupa cinco casillas: necesitar√°s 5 impactos en las posiciones correctas para hundirlo totalmente.

### üå°Ô∏è Ciclo de Vida de un Barco

Un barco pasa por tres estados l√≥gicos:
1.  **Intacto**: Todas sus casillas tienen su n√∫mero original (`1-5`).
2.  **Tocado**: Al menos una de sus casillas ha pasado a ser `6`, pero a√∫n quedan casillas con su n√∫mero original.
3.  **Hundido**: Todas las casillas que compon√≠an ese barco son ahora `6`.

### üß≠ L√≥gica de Desplazamiento: `direcciones[][]`

Para evitar repetir c√≥digo al comprobar o colocar barcos en distintas orientaciones, utilizamos una matriz de desplazamientos (vectores):

```java
private static final int direcciones[][] = { 
    { -1, 0 }, // ARRIBA:    Fila - 1, Columna igual
    { 0, 1 },  // DERECHA:   Fila igual, Columna + 1
    { 1, 0 },  // ABAJO:     Fila + 1, Columna igual
    { 0, -1 }  // IZQUIERDA: Fila igual, Columna - 1
};
```

**¬øC√≥mo se usa?**
Si quieres moverte desde una posici√≥n `(x, y)` hacia la derecha, basta con sumar `direcciones[1][0]` a la `x` y `direcciones[1][1]` a la `y`. Esta t√©cnica permite usar bucles para "explorar" las 4 direcciones de forma elegante en m√©todos como `comprobarDirecciones` o `cantarDisparo`.

---

## üõ†Ô∏è Tareas a Realizar

### 1. Sistema de Colocaci√≥n: `comprobarPosicion`

Es el m√©todo m√°s cr√≠tico a nivel l√≥gico. Debes asegurar que los barcos no se solapen y que haya **al menos una casilla de separaci√≥n** entre ellos.

```java
/**
 * Comprueba si una posici√≥n (x,y) est√° libre para colocar un barco. 
 * Debe haber al menos una casilla vac√≠a entre barco y barco.
 */
public static boolean comprobarPosicion(int x, int y) {
    // TODO: Implementar l√≥gica de proximidad
}
```

### 2. Mec√°nica de Disparo: `disparar`

Actualiza el estado de la matriz cuando alguien lanza un ataque.

```java
/**
 * @return true si se toc√≥ un barco, false si fue agua o disparo repetido.
 */
public static boolean disparar(int[][] matriz, int x, int y) {
    // TODO: 1. Comprobar l√≠mites
    // TODO: 2. Manejar DISPARO REPETIDO: Si la casilla ya es 6 o 7, 
    //         informa al usuario y retorna false (el disparo no es "√∫til").
    // TODO: 3. Si hay un barco (1-5) -> cambiar a 6 y retornar true
    // TODO: 4. Si hay agua (0) -> cambiar a 7 y retornar false
}
```

> **Concepto de Disparo Repetido**: Un buen programa debe evitar que el juego progrese err√≥neamente si el usuario dispara dos veces al mismo sitio. Si dispara a una casilla que ya es `Tocado (6)` o `Agua (7)`, debes indicarlo.

### 3. Interfaz Visual: `mostrarTablero`

Debes imprimir la matriz por consola. Se proporcionan constantes de colores ANSI para que el resultado sea atractivo:

*   Usa `ANSI_CYAN` para el agua disparada (`7`).
*   Usa `ANSI_RED` para los barcos tocados (`6`).
*   Muestra los barcos (`1-5`) con sus colores correspondientes solo si es el tablero del propio jugador.

### 4. Flujo del Juego: `prepararJuego` y `calcularNBarcos`

Antes de empezar a disparar, el juego necesita saber **cu√°ndo termina**. Para ello, usamos un contador de casillas de barco para cada jugador (`nBarcos1` y `nBarcos2`).

#### üéÆ El Bucle de Juego: `jugarPVE`

Este m√©todo es el coraz√≥n de la partida contra la m√°quina. Imagina que es el "√°rbitro" que controla los turnos hasta que uno de los dos se queda sin barcos. Aqu√≠ tienes los pasos l√≥gicos que debes seguir:

1.  **El Bucle Principal**: Todo debe ocurrir dentro de un ciclo que no se detenga mientras el jugador 1 tenga barcos intactos **Y** el jugador 2 (la m√°quina) tambi√©n los tenga. En cuanto uno de los dos contadores llegue a cero, el bucle debe terminar.

2.  **Turno del Jugador (T√∫)**:
    *   Primero, muestra la situaci√≥n actual: imprime tu propio tablero (donde ves tus barcos y los disparos recibidos) y el tablero del rival (donde solo ves tus disparos, pero no sus barcos ocultos).
    *   Solicita por teclado la fila y la columna donde quieres disparar.
    *   Dispara al tablero del rival.
    *   Act√∫a en consecuencia del resultado del disparo, y comunica el resultado al jugador.

3.  **Turno de la M√°quina (CPU)**:
    *   La CPU debe elegir una fila y una columna de forma aleatoria.
    *   Diaspara como objetivo *tu tablero*.
    *   Act√∫a en consecuencia del resultado del disparo, y comunica el resultado al jugador.

4.  **Final de Partida**:
    *   Una vez no queden barcos a flote, la partida se termina.
    *   Comprueba qui√©n se ha quedado sin barcos y muestra un mensaje final de "¬°VICTORIA!" si has ganado t√∫, o de "¬°DERROTA!" si te ha vencido la m√°quina.


#### El M√©todo `calcularNBarcos`

Este m√©todo recibe los arrays de configuraci√≥n (`cantidad` y `tamanios`) y debe calcular el sumatorio total de casillas que ocupan todos los barcos. 
*   **Por ejemplo**: Si hay 5 lanchas (tama√±o 1) y 1 portaaviones (tama√±o 5), el total es $5 \times 1 + 1 \times 5 = 10$ casillas.
*   **Papel en el juego**: Sin este dato, el programa no sabr√≠a cu√°ndo un jugador ha perdido.

#### El M√©todo `prepararJuego`
Es el "director de escena" al inicio:
1.  Genera los tableros aleatorios para J1 y J2 usando `generarTablero()`.
2.  Llama a `calcularNBarcos` para inicializar las variables globales `nBarcos1` y `nBarcos2`.
3.  Muestra los tableros iniciales.
4.  **Orquestaci√≥n**: Llama a `menuJuego()` para saber qu√© quiere el usuario.
5.  **Lanzamiento**: Dependiendo del valor devuelto por el men√∫, invoca a `jugarPVP()` o `jugarPVE()`.

```java
/**
 * Inicializa los tableros, calcula los barcos totales y solicita el modo de juego.
 */
public static void prepararJuego() {
    // 1. Generar tableros
    // 2. Calcular nBarcos iniciales
    // 3. Llamar a menuJuego()
    // 4. Si opci√≥n == 1 -> jugarPVP()
    // 5. Si opci√≥n == 2 -> jugarPVE()
}
```

---

## üöÄ `cantarDisparo`

Este m√©todo es el encargado de dar el mensaje definitivo: "¬øTocado o Hundido?". 

**¬øC√≥mo funciona?**

Cuando un disparo acierta (`tocado`), debemos comprobar si ese impacto ha sido el √∫ltimo necesario para destruir el barco. 
1.  Desde la posici√≥n `(x, y)` impactada, debes "explorar" en las 4 direcciones (arriba, abajo, izquierda, derecha).
2.  Si encuentras alguna casilla adyacente que todav√≠a conserva un n√∫mero de barco (del `1` al `5`), significa que el barco **a√∫n tiene partes intactas** -> Solo es "¬°Tocado!".
3.  Si exploras todas las partes del barco y todas son ahora `6`, entonces el barco est√° **completamente destruido** -> "¬°Hundido!".

```java
/**
 * Determina si un barco ha sido tocado o hundido a partir de la casilla disparada.
 */
public static boolean cantarDisparo(int[][] matriz, int x, int y) {
    // TODO: Explorar el barco en sus 4 direcciones para buscar partes no tocadas.
    return false; // Retorna true si est√° hundido
}
```

---

## üí° Consejos
*   **Modulariza**: No intentes escribir todo en un solo m√©todo. Ap√≥yate en las funciones ya definidas.
*   **Separaci√≥n**: La regla de separaci√≥n entre barcos es vital. Comprueba las casillas adyacentes (incluyendo diagonales) antes de dar el "visto bueno" a una posici√≥n.
*   **M√°quina**: En el modo PVE, haz que la m√°quina elija coordenadas `(x, y)` aleatorias hasta que encuentre una que no haya disparado antes.

---

## üéÆ Simulacro de Partida (Player vs Engine PvE)

Para entender mejor c√≥mo deben interactuar los m√©todos, aqu√≠ tienes un ejemplo de los primeros turnos. Nos fijaremos en una peque√±a secci√≥n del tablero de la CPU para ver los cambios.

### **Turno 1: Jugador dispara a (4, 0) - [FALLO]**
*   **Estado Antes**: La casilla est√° en `0` (Agua).
    ```text
    Fila 4: [ 0, 0, 0, ... ] 
    ```
*   **Acci√≥n**: `disparar(barcosJ2, 4, 0)`.
*   **Resultado**: El m√©todo cambia el `0` por un `7` y retorna `false`.
*   **Estado Despu√©s**:
    ```text
    Fila 4: [ 7, 0, 0, ... ]  <-- ¬°Agua!
    ```

### **Turno 2: Jugador dispara a (2, 2) - [ACIERTO]**
*   **Estado Antes**: Hay un Submarino (`3`) en esa posici√≥n.
    ```text
    Fila 2: [ 0, 0, 3, 3, 3, ... ]
    ```
*   **Acci√≥n**: `disparar(barcosJ2, 2, 2)`.
*   **Resultado**: Cambia `3` por `6` (Tocado) y retorna `true`.
*   **Estado Despu√©s**:
    ```text
    Fila 2: [ 0, 0, 6, 3, 3, ... ]  <-- ¬°Tocado!
    ```

### **Turno 3: Jugador dispara a (2, 2) - [REPETIDO]**
*   **Estado Antes**: El jugador se equivoca y dispara donde ya dio antes.
    ```text
    Fila 2: [ 0, 0, 6, 3, 3, ... ]
    ```
*   **Acci√≥n**: `disparar(barcosJ2, 2, 2)`.
*   **Resultado**: El m√©todo ve que ya es `6`, avisa al usuario y retorna `false`.
*   **Estado Despu√©s**: (Sin cambios)
    ```text
    Fila 2: [ 0, 0, 6, 3, 3, ... ]  <-- "¬°Ya hab√≠as disparado aqu√≠!"
    ```

### **Turno 4: CPU dispara a (0, 0) del Jugador**
*   **Estado Antes**: El jugador tiene una Lancha (`1`) en (0,0).
    ```text
    Tablero J1 - Fila 0: [ 1, 0, 0, ... ]
    ```
*   **Acci√≥n**: La CPU elige (0,0).
*   **Resultado**: `barcosJ1[0][0]` pasa de `1` a `6`.
*   **Estado Despu√©s**:
    ```text
    Tablero J1 - Fila 0: [ 6, 0, 0, ... ]  <-- "La CPU te ha tocado un barco"
    ```

### **Turno 5: Jugador completa el Submarino - [HUNDIDO]**
*   **Estado Antes**: Quedan dos partes del submarino del Turno 2.
    ```text
    Fila 2: [ 0, 0, 6, 3, 3 ]
    ```
*   **Acci√≥n**: El jugador acierta en (2,3) y (2,4) en turnos sucesivos.
*   **L√≥gica**: `cantarDisparo` comprueba que ya no quedan m√°s `3` conectados.
*   **Estado Despu√©s**:
    ```text
    Fila 2: [ 0, 0, 6, 6, 6 ]  <-- ¬°HUNDIDO!
    ```

---

## üé® Tip: Impresi√≥n con Colores ANSI

Para que el tablero sea visualmente claro, puedes combinar las constantes de color con caracteres tem√°ticos. Aqu√≠ tienes un ejemplo de c√≥mo podr√≠as estructurar la l√≥gica de impresi√≥n para cada casilla:

| Estado | Significado | Ejemplo de C√≥digo (Conceptual) | Resultado en Consola |
| :--- | :--- | :--- | :--- |
| **0** | Agua | `ANSI_BLUE + " A "` | ` A ` |
| **1-5** | Barco | `ANSI_WHITE + " B "` | ` B ` |
| **6** | Tocado | `ANSI_RED + " T "` | ` T ` |
| **7** | Agua (Fallo) | `ANSI_CYAN + " D "` | ` D ` |

#### Ejemplo de C√≥digo en Java

```java
// Ejemplo de c√≥mo imprimir una casilla de agua (0)
System.out.print(ANSI_BLUE + " A " + ANSI_RESET);

// Ejemplo de c√≥mo imprimir una casilla de agua disparada (7)
System.out.print(ANSI_CYAN + " D " + ANSI_RESET);

// Ejemplo de c√≥mo imprimir un barco del jugador (1-5)
System.out.print(ANSI_WHITE + " B " + ANSI_RESET);

// Ejemplo de c√≥mo imprimir un barco tocado (6)
System.out.print(ANSI_RED + " T " + ANSI_RESET);
```

> [!TIP]
> Recuerda resetear el color al final de cada casilla o l√≠nea usando `ANSI_RESET` para evitar que el color se "derrame" por el resto de la consola.


**Ejemplo**

```text
    0  1  2  3  4  5  6  7  8  9 
   -------------------------------
0 | A  A  A  A  A  A  A  A  A  A  |
1 | D  D  B  B  B  D  A  A  A  A  |
2 | A  D  A  A  A  A  A  A  A  A  |
3 | A  A  A  A  A  A  A  D  T  A  |
4 | A  A  A  A  A  A  A  A  A  A  |
5 | A  A  A  A  A  B  A  A  A  A  |
6 | A  A  A  A  A  B  A  A  A  A  |
7 | A  A  A  A  A  A  A  A  A  A  |
8 | A  B  A  A  A  A  A  A  A  A  |
9 | A  A  A  A  A  A  A  A  A  A  |
   -------------------------------
```

---

## üìà R√∫brica de Evaluaci√≥n

| Criterio de Evaluaci√≥n | **Logrado (8-10)** | **En Desarrollo (5-7)** | **Requiere Mejora (0-4)** |
| :--- | :--- | :--- | :--- |
| **1. Funcionalidad** | El juego es plenamente funcional (PVP y PVE). Compila sin errores y respeta todas las reglas (hundido, fallos, turnos). | El juego funciona mayoritariamente, pero hay errores puntuales en la l√≥gica de turnos o en la detecci√≥n de victoria. | El programa no es funcional, no compila o tiene errores graves que impiden jugar una partida b√°sica. |
| **2. Uso de Matrices** | Gestiona correctamente las matrices de 10x10. El acceso a posiciones y la comprobaci√≥n de l√≠mites es impecable. | Utiliza las matrices pero comete errores de "√≠ndice fuera de rango" o no actualiza bien los estados de las celdas (0-7). | No demuestra comprensi√≥n del uso de arrays bidimensionales para representar el estado del juego. |
| **3. Modularizaci√≥n** | Utiliza correctamente los **m√©todos base proporcionados**. El c√≥digo est√° bien repartido y no hay l√≥gica duplicada. | Implementa los m√©todos pero no los conecta bien entre s√≠ o ignora algunas de las funciones sugeridas (ej: `getValorCelda`). | El c√≥digo est√° acumulado en pocos m√©todos gigantes. Ignora la estructura modular propuesta. |
| **4. Claridad y Organizaci√≥n** | El c√≥digo est√° perfectamente indentado. Usa nombres de variables claros y comentarios pertinentes en bloques l√≥gicos. | El c√≥digo es legible pero desordenado en algunos puntos. Algunos nombres de variables no son suficientemente descriptivos. | El c√≥digo es ca√≥tico, dif√≠cil de seguir y carece de una estructura de nombres coherente. |
